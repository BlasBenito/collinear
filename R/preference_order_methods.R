# AUTO SELECTION ----


#' Automatic Selection of Function to Compute Preference Order
#'
#' @description
#' Internal function to select a proper \code{f_...()} function to compute preference order depending on the types of the response variable and the predictors. The selection criteria is available as a data frame generated by [f_auto_rules()].
#'
#'
#' @inheritParams collinear
#'
#' @param response (optional, character string) Name of a response variable in \code{df}. Default: NULL.
#'
#' @return function name
#' @family preference_order_tools
#' @export
#' @autoglobal
#' @examples
#' data(vi, vi_predictors_numeric)
#' f <- f_auto(
#'   df = vi[1:1000, ],
#'   response = "vi_numeric",
#'   predictors = vi_predictors_numeric
#'   )
f_auto <- function(
    df = NULL,
    response = NULL,
    predictors = NULL,
    quiet = FALSE,
    ...
){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_auto()",
    ... = ...
  )

  quiet <- validate_arg_quiet(
    quiet = quiet,
    function_name = function_name
  )

  df <- validate_arg_df(
    df = df,
    responses = response,
    predictors = predictors,
    function_name = function_name,
    quiet = quiet
  )

  response <- validate_arg_response(
    df = df,
    response = response,
    function_name = function_name,
    quiet = quiet
  )

  predictors <- validate_arg_predictors(
    df = df,
    response = response,
    predictors = predictors,
    function_name = function_name,
    quiet = quiet
  )

  #data frame with heuristic
  rules <- f_auto_rules()

  response_type <- identify_response_type(
    df = df,
    response = response,
    quiet = quiet,
    function_name = function_name
  )

  if(response_type == "unknown"){
    stop(
      function_name,
      ": response type is 'unknown', please select an f_...() function suitable for your response data.",
      call. = FALSE
    )
  }

  predictors_type <- identify_predictors_type(
    df = df,
    predictors = predictors,
    function_name = function_name
  )

  if(predictors_type == "unknown"){
    stop(
      "\n",
      function_name,
      ": predictors type is 'unknown', please select an f_...() function suitable for your predictor data.",
      call. = FALSE
    )
  }

  #select function
  f_name <- rules[
    rules$response_type == response_type &
      rules$predictors_type == predictors_type,
    "name"
  ]

  if(quiet == FALSE){

    message(
      "\n",
      function_name,
      ": selected function '",
      f_name,
      "()' to compute preference order."
    )

  }


  f_name

}

#' Data Frame of Preference Functions
#'
#' @return data frame
#' @export
#' @autoglobal
#' @family preference_order_tools
#' @examples
#' f_functions()
f_functions <- function(){

  f_list <- list(
    c("f_r2_pearson", "numeric", "numeric", "cor(x, y, method = 'pearson')^2", "R2"),
    c("f_r2_spearman", "numeric", "numeric", "cor(x, y, method = 'spearman')^2", "pseudo R2"),
    c("f_r2_glm_gaussian", "numeric", "numeric, categorical", "stats::glm(y ~ x, family = gaussian(link = 'identity'))", "R2"),
    c("f_r2_glm_gaussian_poly2", "numeric", "numeric, categorical", "stats::glm(y ~ poly(x, degree = 2, raw = TRUE), family = gaussian(link = 'identity'))", "R2"),
    c("f_r2_gam_gaussian", "numeric", "numeric, categorical", "mgcv::gam(y ~ s(x), family = gaussian(link = 'identity'))", "R2"),
    c("f_r2_rpart", "numeric", "numeric, categorical", "rpart::rpart(y ~ x)", "R2"),
    c("f_r2_rf", "numeric", "numeric, categorical", "ranger::ranger(y ~ x)", "R2"),
    c("f_r2_glm_poisson", "integer counts", "numeric, categorical", "stats::glm(y ~ x, family = poisson(link = 'log'))", "R2"),
    c("f_r2_glm_poisson_poly2", "integer counts", "numeric, categorical", "stats::glm(y ~ poly(x, degree = 2, raw = TRUE), family = poisson(link = 'log'))", "R2"),
    c("f_r2_gam_poisson", "integer counts", "numeric, categorical", "mgcv::gam(y ~ s(x), family = poisson(link = 'log'))", "R2"),
    c("f_auc_glm_binomial", "binomial", "numeric, categorical", "stats::glm(y ~ x, family = quasibinomial(link = 'logit'), weights = case_weights(y))", "AUC"),
    c("f_auc_glm_binomial_poly2", "binomial", "numeric, categorical", "stats::glm(y ~ poly(x, degree = 2, raw = TRUE), family = quasibinomial(link = 'logit'), weights = collinear::case_weights(y))", "AUC"),
    c("f_auc_glm_binomial_poly2", "binomial", "numeric, categorical", "stats::glm(y ~ poly(x, degree = 2, raw = TRUE), family = quasibinomial(link = 'logit'), weights = collinear::case_weights(y))", "AUC"),
    c("f_auc_gam_binomial", "binomial", "numeric, categorical", "mgcv::gam(y ~ s(x), family = quasibinomial(link = 'logit'), weights = collinear::case_weights(y))", "AUC"),
    c("f_auc_rpart", "binomial", "numeric, categorical", "rpart::rpart(y ~ x, weights = collinear::case_weights(y))", "AUC"),
    c("f_auc_rf", "binomial", "numeric, categorical", "ranger::ranger(y ~ x, case.weights = collinear::case_weights(y))", "AUC"),
    c("f_v", "categorical", "categorical", "collinear::cor_cramer_v(x, y)", "Cramer's V"),
    c("f_v_rf_categorical", "categorical", "numeric, categorical", "ranger::ranger(y ~ x, case.weights = collinear::case_weights(y))", "Cramer's V")
  )

  f_df <- f_list |>
    as.data.frame() |>
    t() |>
    as.data.frame()

  rownames(f_df) <- NULL

  colnames(f_df) <- c(
    "name",
    "response_type",
    "predictors_types",
    "expression",
    "preference_metric"
  )

  f_df

}


#' Rules to Select Default f Argument to Compute Preference Order
#'
#' @description
#' Data frame with rules used by [f_auto()] to select the function \code{f} to compute preference order in [preference_order()].
#'
#'
#' @return data frame
#' @family preference_order_tools
#' @export
#' @autoglobal
#' @examples
#' f_auto_rules()
f_auto_rules <- function(){

  data.frame(
    name = c(
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_pearson",
      "f_r2_rf",
      "f_r2_rf",
      "f_auc_rf",
      "f_auc_rf",
      "f_auc_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_v_rf_categorical",
      "f_v",
      "f_v_rf_categorical"
    ),
    response_type = c(
      "continuous-binary",
      "continuous-binary",
      "continuous-binary",
      "continuous-low",
      "continuous-low",
      "continuous-low",
      "continuous-high",
      "continuous-high",
      "continuous-high",
      "integer-binomial",
      "integer-binomial",
      "integer-binomial",
      "integer-binary",
      "integer-binary",
      "integer-binary",
      "integer-low",
      "integer-low",
      "integer-low",
      "integer-high",
      "integer-high",
      "integer-high",
      "categorical",
      "categorical",
      "categorical"
    ),
    predictors_type = c(
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed"
    )
  )

}



# NUMERIC RESPONSE ----

#' Association Between a Continuous Response and a Continuous Predictor
#'
#' @description
#' These functions take a data frame with two numeric continuous columns "x" (predictor) and "y" (response), fit a univariate model, and return the R2 of the observations versus the model predictions:
#' \itemize{
#'
#'   \item \code{f_r2_pearson()}: Pearson's R2.
#'
#'   \item \code{f_r2_spearman()}: Spearman's R2.
#'
#'   \item \code{f_r2_glm_gaussian()}: Pearson's R2 of a GLM model fitted with [stats::glm()], with formula \code{y ~ s(x)} and family \code{stats::gaussian(link = "identity")}.
#'
#'   \item \code{f_r2_glm_gaussian_poly2()}: Pearson's R2 of a GLM model fitted with [stats::glm()], with formula \code{y ~ stats::poly(x, degree = 2, raw = TRUE)} and family \code{stats::gaussian(link = "identity")}.
#'
#'   \item \code{f_r2_gam_gaussian()}: Pearson's R2 of a GAM model fitted with [mgcv::gam()], with formula \code{y ~ s(x)} and family \code{stats::gaussian(link = "identity")}.

#'   \item \code{f_r2_rpart()}: Pearson's R2 of a Recursive Partition Tree fitted with [rpart::rpart()] with formula \code{y ~ x}.
#'
#'   \item \code{f_r2_rf()}: Pearson's R2 of a 100 trees Random Forest model fitted with [ranger::ranger()] and formula \code{y ~ x}.
#'
#' }
#'
#' @param df (required, data frame) with columns:
#' \itemize{
#'   \item \code{x}: (numeric) continuous predictor.
#'   \item \code{y} (numeric) continuous response.
#' }
#' @inheritParams collinear
#' @return numeric: R2
#' @examples
#'
#load example data
#' data(vi)
#'
#' #reduce size to speed-up example
#' vi <- vi[1:1000, ]
#'
#' #numeric response and predictor
#' #to data frame without NAs
#' df <- data.frame(
#'   y = vi[["vi_numeric"]],
#'   x = vi[["swi_max"]]
#' ) |>
#'   na.omit()
#'
#' # Continuous response
#'
#' #Pearson R2
#' f_r2_pearson(df = df)
#'
#' #Spearman R2
#' f_r2_spearman(df = df)
#'
#' #R2 of a gaussian gam
#' f_r2_glm_gaussian(df = df)
#'
#' #gaussian glm with second-degree polynomials
#' f_r2_glm_gaussian_poly2(df = df)
#'
#' #R2 of a gaussian gam
#' f_r2_gam_gaussian(df = df)
#'
#' #recursive partition tree
#' f_r2_rpart(df = df)
#'
#' #random forest model
#' f_r2_rf(df = df)
#' @autoglobal
#' @rdname f_r2
#' @family preference_order_functions
#' @examples
#'
#' #load example data
#' data(vi)
#'
#' #reduce size to speed-up example
#' vi <- vi[1:1000, ]
#'
#' #continuous response and predictor
#' #to data frame without NAs
#' df <- data.frame(
#'   y = vi[["vi_numeric"]],
#'   x = vi[["swi_max"]]
#' ) |>
#'   na.omit()
#'
#' # Continuous response
#'
#' #Pearson R2
#' f_r2_pearson(df = df)
#'
#' #Spearman R2
#' f_r2_spearman(df = df)
#'
#' #R2 of a gaussian gam
#' f_r2_glm_gaussian(df = df)
#'
#' #gaussian glm with second-degree polynomials
#' f_r2_glm_gaussian_poly2(df = df)
#'
#' #R2 of a gaussian gam
#' f_r2_gam_gaussian(df = df)
#'
#' #recursive partition tree
#' f_r2_rpart(df = df)
#'
#' #random forest model
#' f_r2_rf(df = df)
#'
#' @name f_r2
NULL

#' @autoglobal
#' @rdname f_r2
#' @family preference_order_functions
#' @export
f_r2_pearson <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_pearson()",
    ... = ...
  )

  stats::cor(
    x = df[["x"]],
    y = df[["y"]],
    method = "pearson"
  )^2

}


#' @autoglobal
#' @rdname f_r2
#' @family preference_order_functions
#' @export
f_r2_spearman <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_spearman()",
    ... = ...
  )

  tryCatch(
    {

      stats::cor(
        x = df[["x"]],
        y = df[["y"]],
        method = "spearman"
      )^2

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )



}

#' @autoglobal
#' @rdname f_r2
#' @family preference_order_functions
#' @export
f_r2_glm_gaussian <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_glm_gaussian()",
    ... = ...
  )

  tryCatch(
    {

      p <- stats::glm(
        formula = y ~ x,
        data = df,
        family = stats::gaussian(
          link = "identity"
        )
      ) |>
        stats::predict(
          type = "response"
        ) |>
        suppressWarnings() |>
        suppressMessages()

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_r2(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}


#' @autoglobal
#' @rdname f_r2
#' @family preference_order_functions
#' @export
f_r2_glm_gaussian_poly2 <- function(
    df,
    ...
    ){


  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_glm_gaussian_poly2()",
    ... = ...
  )

  tryCatch(
    {

      p <- stats::glm(
        formula = y ~ stats::poly(
          x,
          degree = 2,
          raw = TRUE
        ),
        data = df,
        family = stats::gaussian(
          link = "identity"
        )
      ) |>
        stats::predict(
          type = "response"
        ) |>
        suppressWarnings() |>
        suppressMessages()

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_r2(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}


#' @autoglobal
#' @rdname f_r2
#' @family preference_order_functions
#' @export
f_r2_gam_gaussian <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_gam_gaussian()",
    ... = ...
  )

  tryCatch(
    {

      p <- mgcv::gam(
        formula = y ~ s(x),
        data = df,
        family = stats::gaussian(link = "identity"),
        select = TRUE
      ) |>
        stats::predict(
          type = "response"
        )

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_r2(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}



#' @autoglobal
#' @rdname f_r2
#' @family preference_order_functions
#' @export
f_r2_rpart <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_rpart()",
    ... = ...
  )

  tryCatch(
    {

      p <- rpart::rpart(
        formula = y ~ x,
        data = df,
        control = rpart::rpart.control(
          minbucket = floor(nrow(df) * 0.05)
        )
      ) |>
        stats::predict(
          type = "vector"
        )

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_r2(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}

#' @autoglobal
#' @rdname f_r2
#' @family preference_order_functions
#' @export
f_r2_rf <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_rf()",
    ... = ...
  )

  tryCatch(
    {

      m <- ranger::ranger(
        formula = y ~ x,
        data = df,
        num.threads = 1,
        num.trees = 100,
        min.node.size = floor(nrow(df) * 0.05),
        seed = 1
      )

      p <- stats::predict(
        object = m,
        data = df
      )$predictions

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )


  performance_score_r2(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}

# COUNTS RESPONSE ----

#' Association Between a Count Response and a Continuous Predictor
#'
#' @description
#' These functions take a data frame with a integer counts response "y", and a continuous predictor "x", fit a univariate model, and return the R2 of observations versus predictions:
#' \itemize{
#'
#'   \item \code{f_r2_glm_poisson()} Pearson's R2 between a count response and the predictions of a GLM model with formula \code{y ~ x} and family \code{stats::poisson(link = "log")}.
#'
#'   \item \code{f_r2_glm_poisson_poly2()} Pearson's R2 between a count response and the predictions of a GLM model with formula \code{y ~ stats::poly(x, degree = 2, raw = TRUE)} and family \code{stats::poisson(link = "log")}.
#'
#'   \item \code{f_r2_gam_poisson()} Pearson's R2 between a count response and the predictions of a [mgcv::gam()] model with formula \code{y ~ s(x)} and family \code{stats::poisson(link = "log")}.
#'
#'   \item \code{f_r2_rpart()}: Pearson's R2 of a Recursive Partition Tree fitted with [rpart::rpart()] with formula \code{y ~ x}.
#'
#'   \item \code{f_r2_rf()}: Pearson's R2 of a 100 trees Random Forest model fitted with [ranger::ranger()] and formula \code{y ~ x}.
#' }
#'
#' @param df (required, data frame) with columns:
#' \itemize{
#'   \item "x": (numeric) continuous predictor.
#'   \item "y" (integer) counts response.
#' }
#' @inheritParams collinear
#' @rdname f_r2_counts
#' @family preference_order_functions
#' @examples
#'
#' #load example data
#' data(vi)
#'
#' #reduce size to speed-up example
#' vi <- vi[1:1000, ]
#'
#' #integer counts response and continuous predictor
#' #to data frame without NAs
#' df <- data.frame(
#'   y = vi[["vi_counts"]],
#'   x = vi[["swi_max"]]
#' ) |>
#'   na.omit()
#'
#' #GLM model with Poisson family
#' f_r2_glm_poisson(df = df)
#'
#' #GLM model with second degree polynomials and Poisson family
#' f_r2_glm_poisson_poly2(df = df)
#'
#' #GAM model with Poisson family
#' f_r2_gam_poisson(df = df)
#' @name f_r2_counts
NULL


#' @autoglobal
#' @rdname f_r2_counts
#' @family preference_order_functions
#' @export
f_r2_glm_poisson <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_glm_poisson()",
    ... = ...
  )

  tryCatch(
    {

      p <- stats::glm(
        formula = y ~ x,
        data = df,
        family = stats::poisson(
          link = "log"
        )
      ) |>
        stats::predict(
          type = "response"
        ) |>
        suppressWarnings() |>
        suppressMessages()

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_r2(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}

#' @autoglobal
#' @rdname f_r2_counts
#' @family preference_order_functions
#' @export
f_r2_glm_poisson_poly2 <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_glm_poisson_poly2()",
    ... = ...
  )

  tryCatch(
    {

      p <- stats::glm(
        formula = y ~ stats::poly(
          x,
          degree = 2,
          raw = TRUE
        ),
        data = df,
        family = stats::poisson(
          link = "log"
        )
      ) |>
        stats::predict(
          type = "response"
        ) |>
        suppressWarnings() |>
        suppressMessages()

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_r2(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}


#' @autoglobal
#' @rdname f_r2_counts
#' @family preference_order_functions
#' @export
f_r2_gam_poisson <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_r2_gam_poisson()",
    ... = ...
  )

  tryCatch(
    {

      p <- mgcv::gam(
        formula = y ~ s(x),
        data = df,
        family = stats::poisson(link = "log"),
        select = TRUE
      ) |>
        stats::predict(
          type = "response"
        )

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )


  performance_score_r2(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}

# BINOMIAL RESPONSE ----

#' Association Between a Binomial Response and a Continuous Predictor
#'
#' @description
#' These functions take a data frame with a binomial response "y" with unique values 1 and 0, and a continuous predictor "x", fit a univariate model, to return the Area Under the ROC Curve (AUC) of observations versus predictions:
#' \itemize{
#'
#'   \item \code{f_auc_glm_binomial()}: AUC of a binomial response against the predictions of a GLM model with formula \code{y ~ x}, family \code{stats::quasibinomial(link = "logit")}, and weighted cases (see [case_weights()]) to control for unbalanced data.
#'
#'   \item \code{f_auc_glm_binomial_poly2()}: AUC of a binomial response against the predictions of a GLM model with formula \code{y ~ stats::poly(x, degree = 2, raw = TRUE)}, family \code{stats::quasibinomial(link = "logit")}, and weighted cases (see [case_weights()]) to control for unbalanced data.
#'
#'   \item \code{f_auc_gam_binomial()}: AUC  of a GAM model with formula  \code{y ~ s(x)}, family \code{stats::quasibinomial(link = "logit")}, and weighted cases.
#'
#'   \item \code{f_auc_rpart()}: AUC of a Recursive Partition Tree with weighted cases.
#'
#'   \item \code{f_auc_rf()}: AUC of a Random Forest model with weighted cases.
#' }
#'
#' @param df (required, data frame) with columns:
#' \itemize{
#'   \item "x": (numeric) continuous predictor.
#'   \item "y" (integer) binomial response with unique values 0 and 1.
#' }
#' @inheritParams collinear
#' @family preference_order_functions
#' @examples
#' #load example data
#' data(vi)
#'
#' #reduce size to speed-up example
#' vi <- vi[1:1000, ]
#'
#' #integer counts response and continuous predictor
#' #to data frame without NAs
#' df <- data.frame(
#'   y = vi[["vi_binomial"]],
#'   x = vi[["swi_max"]]
#' ) |>
#'   na.omit()
#'
#' #AUC of GLM with binomial response and weighted cases
#' f_auc_glm_binomial(df = df)
#'
#' #AUC of GLM as above plus second degree polynomials
#' f_auc_glm_binomial_poly2(df = df)
#'
#' #AUC of binomial GAM with weighted cases
#' f_auc_gam_binomial(df = df)
#'
#' #AUC of recursive partition tree with weighted cases
#' f_auc_rpart(df = df)
#'
#' #AUC of random forest with weighted cases
#' f_auc_rf(df = df)
#' @name f_auc
NULL

#' @autoglobal
#' @rdname f_auc
#' @family preference_order_functions
#' @export
f_auc_glm_binomial <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_auc_glm_binomial()",
    ... = ...
  )

  tryCatch(
    {

      p <- stats::glm(
        formula = y ~ x,
        data = df,
        family = stats::quasibinomial(
          link = "logit"
        ),
        weights = case_weights(
          x = df[["y"]],
          function_name = function_name
        )
      ) |>
        stats::predict(
          type = "response"
        ) |>
        suppressWarnings() |>
        suppressMessages()


    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_auc(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}


#' @autoglobal
#' @rdname f_auc
#' @family preference_order_functions
#' @export
f_auc_glm_binomial_poly2 <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_auc_glm_binomial_poly2()",
    ... = ...
  )

  tryCatch(
    {

      p <- stats::glm(
        formula = y ~ stats::poly(
          x,
          degree = 2,
          raw = TRUE
        ),
        data = df,
        family = stats::quasibinomial(
          link = "logit"
        ),
        weights = case_weights(
          x = df[["y"]],
          function_name = function_name
        )
      ) |>
        stats::predict(
          type = "response"
        ) |>
        suppressWarnings() |>
        suppressMessages()


    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )


  performance_score_auc(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}

#' @autoglobal
#' @rdname f_auc
#' @family preference_order_functions
#' @export
f_auc_gam_binomial <- function(
    df,
    ...
    ){


  function_name <- validate_arg_function_name(
    default_name = "collinear::f_auc_gam_binomial()",
    ... = ...
  )

  tryCatch(
    {

      p <- mgcv::gam(
        formula = y ~ s(x),
        data = df,
        family = stats::quasibinomial(link = "logit"),
        weights = case_weights(
          x = df[["y"]],
          function_name = function_name
        ),
        select = TRUE
      ) |>
        stats::predict(
          type = "response"
        ) |>
        suppressWarnings() |>
        suppressMessages()


    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_auc(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}

#' @autoglobal
#' @rdname f_auc
#' @family preference_order_functions
#' @export
f_auc_rpart <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_auc_rpart()",
    ... = ...
  )

  tryCatch(
    {

      p <- rpart::rpart(
        formula = y ~ x,
        data = df,
        weights = case_weights(
          x = df[["y"]],
          function_name = function_name
          ),
        control = rpart::rpart.control(
          minbucket = floor(nrow(df) * 0.05)
        )
      ) |>
        stats::predict(
          type = "vector"
        )



    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )


  performance_score_auc(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}

#' @autoglobal
#' @rdname f_auc
#' @family preference_order_functions
#' @export
f_auc_rf <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_auc_rf()",
    ... = ...
  )

  tryCatch(
    {

      m <- ranger::ranger(
        formula = y ~ x,
        data = df,
        case.weights = case_weights(
          x = df[["y"]],
          function_name = function_name
        ),
        num.threads = 1,
        num.trees = 100,
        min.node.size = floor(nrow(df) * 0.05),
        seed = 1
      )

      p <- stats::predict(
        object = m,
        data = df
      )$predictions

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_auc(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}

# CATEGORICAL RESPONSE ----

#' Association Between a Categorical Response and a Categorical Predictor
#'
#' @description
#' Computes Cramer's V, a measure of association between categorical or factor variables. Please see [cor_cramer_v()] for further details.
#'
#' @param df (required, data frame) with columns:
#' \itemize{
#'   \item "x": (character or factor) categorical predictor.
#'   \item "y": (character or factor) categorical response.
#' }
#' @inheritParams collinear
#' @return numeric: Cramer's V
#' @examples
#' #load example data
#' data(vi)
#'
#' #reduce size to speed-up example
#' vi <- vi[1:1000, ]
#'
#' #categorical response and predictor
#' #to data frame without NAs
#' df <- data.frame(
#'   y = vi[["vi_factor"]],
#'   x = vi[["soil_type"]]
#' ) |>
#'   na.omit()
#'
#' #Cramer's V
#' f_v(df = df)
#' @autoglobal
#' @family preference_order_functions
#' @export
f_v <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_v()",
    ... = ...
  )

  cor_cramer_v(
    x = df[["x"]],
    y = df[["y"]],
    check_input = TRUE,
    function_name = function_name
  )

}

#' Association Between a Categorical Response and a Categorical or Numeric Predictor
#'
#' @description
#' Computes the Cramer's V between a categorical response (of class "character" or "factor") and the prediction of a Random Forest model with a categorical or numeric predictor and weighted cases.
#'
#' @param df (required, data frame) with columns:
#' \itemize{
#'   \item "x": (character, factor, or numeric) categorical or numeric predictor.
#'   \item "y" (character or factor) categorical response.
#' }
#' @inheritParams collinear
#' @return numeric: Cramer's V
#' @examples
#' #load example data
#' data(vi)
#'
#' #reduce size to speed-up example
#' vi <- vi[1:1000, ]
#'
#' #categorical response and predictor
#' #to data frame without NAs
#' df <- data.frame(
#'   y = vi[["vi_factor"]],
#'   x = vi[["soil_type"]]
#' ) |>
#'   na.omit()
#'
#' #Cramer's V of a Random Forest model
#' f_v_rf_categorical(df = df)
#'
#' #categorical response and numeric predictor
#' df <- data.frame(
#'   y = vi[["vi_factor"]],
#'   x = vi[["swi_mean"]]
#' ) |>
#'   na.omit()
#'
#' f_v_rf_categorical(df = df)
#' @autoglobal
#' @family preference_order_functions
#' @export
f_v_rf_categorical <- function(
    df,
    ...
    ){

  function_name <- validate_arg_function_name(
    default_name = "collinear::f_v_rf_categorical()",
    ... = ...
  )

  tryCatch(
    {

      df[["y"]] <- as.factor(df[["y"]])

      m <- ranger::ranger(
        formula = y ~ x,
        data = df,
        case.weights = case_weights(
          x = df[["y"]],
          function_name = function_name
        ),
        num.threads = 1,
        num.trees = 100,
        min.node.size = floor(nrow(df) * 0.05),
        seed = 1
      )

      p <- stats::predict(
        object = m,
        data = df
      )$predictions

    },
    error = function(e) {

      stop(
        "\n",
        function_name,
        ": ", conditionMessage(e), call. = FALSE)
    }

  )

  performance_score_v(
    o = df[["y"]],
    p = p,
    function_name = function_name
  )

}


