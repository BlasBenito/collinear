---
title: "Adaptive Filtering Thresholds"
output: 
  rmarkdown::html_document:
    toc: true
    toc_title: "Content"
    source: false
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

## Summary

The function `collinear()` automatically configures multicollinearity filtering thresholds when the arguments `max_cor` and `max_vif` are not specified. This adaptive approach:

- Eliminates the guesswork of choosing threshold values.
- Adapts filtering intensity to the correlation structure of the data.
- Keeps output VIF bounded within sensible limits (approximately 2.5 to 7.5).
- Allows manual override when specific thresholds are needed.

This article explains how the automatic threshold configuration works, demonstrates its effectiveness across varied datasets, and provides guidance on when manual configuration might be preferred.

## Setup

For this article we need the following packages and configuration. Notice the vector `predictors_high_collinearity` with a subset of `vi_predictors_numeric` with a very high collinearity.

```{r, message = FALSE, warning = FALSE, results = "hide"}
library(collinear)
library(future)
library(ggplot2)
library(patchwork)

#parallelization setup
#only useful for categorical predictors
future::plan(
  future::multisession,
  workers = future::availableCores() - 1
)

#progress bar (does not work in Rmarkdown)
#progressr::handlers(global = TRUE)

#example data
data(
  vi_smol, 
  vi_predictors_numeric,
  experiment_adaptive_thresholds
  )
```


## Adaptive Threshold Selection

The arguments `max_cor` and `max_vif` define the maximum pairwise correlation and variance inflation factors allowed during multicollinearity filtering. 

Unlike `collinear_select()`, `cor_select()`, and `vif_select()`, which use fixed defaults (`max_cor = 0.7`, `max_vif = 5`), the function `collinear()` sets these to NULL and computes appropriate thresholds from the data.

Let me show you why.

The vector `vi_predictors_numeric` names numeric predictors with a moderate multicollinearity, as the stats below show.

```{r}
collinear::collinear_stats(
  df = vi_smol,
  predictors = vi_predictors_numeric
) |> 
  dplyr::filter(
    statistic %in% c("quantile_0.75", "maximum")
  )
```

We can run them through `collinear()`.

```{r}
x <- collinear::collinear(
  df = vi_smol,
  predictors = vi_predictors_numeric
)
```

The first two messages above indicate the values of `max_cor` and `max_vif` selected by `collinear()` based on the data properties (more about that later). 

The last message indicates the predictors selected in this run. Their stats are shown below.

```{r}
collinear::collinear_stats(
  df = x$result$df,
  predictors = x$result$selection
) |> 
  dplyr::filter(
    statistic %in% c("quantile_0.75", "maximum")
  )
```

These stats show very reasonable VIF scores now.

However, if you are aiming for specific multicollinearity thresholds, the automatic setup can be overriden by providing the desired values for `max_cor` and/or `max_vif`. If one of them is not defined, it will be ignored.

```{r}
x <- collinear::collinear(
  df = vi_smol,
  predictors = vi_predictors_numeric,
  max_cor = 0.7,
  max_vif = 5
)

collinear::collinear_stats(
  df = x$result$df,
  predictors = x$result$selection
) |> 
  dplyr::filter(
    statistic %in% c("quantile_0.75", "maximum")
  )
```
By adapting thresholds to each dataset's structure, `collinear()` provides sensible defaults while still allowing manual override when needed.

## Effectiveness

To assess the effectiveness of this adaptive threshold selection method I ran `collinear()` on 10.000 random subsets between 4 and 100 randomly selected columns of a 500 columns and 3000 rows dataset, and compared the input and output multicollinearity stats and number of predictors across runs.

The results of this simulation are in the dataframe [experiment_adaptive_thresholds], summarized below. 

The left panel shows the quantile 0.75 of the input correlation, against the mximum VIF of the resulting selection. The right panel shows the number of predictors before and after multicollinearity filtering.

```{r, echo = FALSE, fig.width=8, fig.height=3.5}
cor_plot <- experiment_adaptive_thresholds |>
  ggplot2::ggplot() +
  ggplot2::aes(
    x = input_cor_q75,
    y = output_vif_max,
    color = input_predictors
  ) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::scale_color_viridis_c(option = "turbo", direction = 1) +
  ggplot2::labs(
    title = "Input Correlation vs Output VIF",
    x = "Input Correlation (quantile 0.75)",
    y = "Output Maximum VIF",
    color = "Input\nPredictors"
  ) +
  ggplot2::theme_bw()

preds_plot <- experiment_adaptive_thresholds |>
  ggplot2::ggplot() +
  ggplot2::aes(
    x = input_predictors,
    y = output_predictors,
    color = output_vif_max
  ) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::geom_smooth(method = "gam", formula = y ~ s(x, k = 3), color = "gray50", se = TRUE) +
  ggplot2::scale_color_viridis_c(option = "turbo", direction = 1) +
  ggplot2::labs(
    title = "Input vs. Selected Predictors",
    x = "Input Predictors",
    y = "Selected Predictors",
    color = "Output\nmax VIF"
  ) +
  ggplot2::scale_y_continuous(breaks = c(0, 5, 10, 15, 20)) +
  ggplot2::theme_bw()

cor_plot | preds_plot
```

The simulation results shows that the adaptive threshold selection works well in most use cases.


## Step By Step

The adaptive selection of multicollinearity thresholds requires three steps:

**1.** Compute the quantile 0.75 of the correlation for the input predictors via [cor_stats()].

```{r}
cor_0.75 <- collinear::cor_stats(
  df = vi_smol,
  predictors = vi_predictors_numeric,
  quiet = TRUE
) |> 
  dplyr::filter(statistic == "quantile_0.75") |> 
  dplyr::pull(value)

cor_0.75
```
The 75th percentile of correlations is used rather than the median because it better captures where problematic multicollinearity begins — the upper tail of the correlation distribution.

**2.** Sigmoidal transformation of the `cor_0.75` value.

```{r}
max_cor <- 0.545 + 0.24 / (1 + exp(-15 * (cor_0.75 - 0.665)))

max_cor
```

This sigmoid function smoothly maps the input correlation to a bounded `max_cor` threshold:

 - `0.545`: floor of the curve, corresponding to VIF ≈ 2.5 (conservative filtering).
 - `0.785`: ceiling of the curve (0.545 + 0.24), corresponding to VIF ≈ 7.5 (permissive filtering).
 - `0.665`: midpoint where the transition is steepest.
 - `-15`: steepness parameter controlling how sharply the curve transitions.
 
The full sigmoid curve is shown below.

```{r, echo = FALSE, fig.width=6, fig.height=3.5}
sigmoid_df <- data.frame(
  cor_input = seq(0, 1, by = 0.01)
) |>
  dplyr::mutate(
    max_cor = 0.545 + 0.24 / (1 + exp(-15 * (cor_input - 0.665)))
  )

ggplot2::ggplot(sigmoid_df) +
  ggplot2::aes(x = cor_input, y = max_cor) +
  ggplot2::geom_line(linewidth = 1, color = "red4") +
  ggplot2::geom_hline(yintercept = c(0.545, 0.785), linetype = "dashed", alpha = 0.5) +
  ggplot2::geom_vline(xintercept = 0.665, linetype = "dotted", alpha = 0.5) +
  ggplot2::labs(
    title = "Sigmoid Transformation",
    x = "Input Correlation (quantile 0.75)",
    y = "Adaptive max_cor threshold"
  ) +
  ggplot2::annotate("text", x = 0.15, y = 0.56, label = "floor (VIF ≈ 2.5)", size = 3) +
  ggplot2::annotate("text", x = 0.15, y = 0.80, label = "ceiling (VIF ≈ 7.5)", size = 3) +
  ggplot2::theme_bw()
```

Datasets with low correlation (quantile 0.75 < 0.5) receive thresholds near the floor, while highly correlated datasets (quantile 0.75 > 0.8) approach the ceiling. This prevents both over-filtering of clean datasets and under-filtering of problematic ones.

3. The pre-trained GAM model [gam_cor_to_vif] predicts a suitable `max_vif` from the `max_cor` resulting from the transformation.

```{r}
max_vif <- mgcv::predict.gam(
  object = collinear::gam_cor_to_vif,
  newdata = data.frame(max_cor = max_cor)
) 

max_vif
```
The model [gam_cor_to_vif] returns the `max_vif` value that produces the most similar variable selection to a given `max_cor`.

This model was fitted on the simulation results in [experiment_cor_vs_vif], where both filtering methods were applied across 10,000 random dataset configurations. For each `max_cor` value, the `max_vif` producing the highest Jaccard similarity between the two selections was identified.

The model uses cubic weights on the Jaccard similarity scores to emphasize cases where the two methods achieved strong agreement.

```{r}
m <- mgcv::gam(
  formula = max_vif ~ s(max_cor, k = 9),
  weights = experiment_cor_vs_vif$selection_similarity^3,
  data = experiment_cor_vs_vif,
  select = TRUE
)

summary(m)
```
The plot below shows the simulation results and the fitted model.

```{r, echo = FALSE, fig.width=7, fig.height=3.5}

collinear::experiment_cor_vs_vif |> 
  dplyr::arrange(
    selection_similarity
  ) |> 
ggplot2::ggplot() + 
  ggplot2::aes(
    x = max_cor,
    y = max_vif,
    color = selection_similarity,
    weight = selection_similarity^3
  ) + 
  ggplot2::geom_point(alpha = 0.5) + 
  ggplot2::geom_smooth(
    method = "gam",
    formula = y ~ s(x, k = 9),
    method.args = list(
      select = TRUE
    ),
    color = "black",
    se = TRUE
  ) +
  ggplot2::scale_color_viridis_c(
    option = "turbo", 
    direction = 1
    ) + 
  ggplot2::labs(
    title = "Experiment Correlation vs. VIF",
    x = "Input max_cor",
    y = "max_vif with most similar selection",
    color = "Jaccard\nsimilarity\nbetween\nselections"
  ) + 
  ggplot2::theme_bw()
```


The adaptive threshold system in `collinear()` removes the guesswork from multicollinearity filtering by:

**Assessing the data**: Using the 75th percentile of pairwise correlations to characterize the dataset's correlation structure.

**Applying bounded adaptation**: A sigmoid transformation maps this statistic to a `max_cor` threshold between 0.545 (VIF ≈ 2.5) and 0.785 (VIF ≈ 7.5), ensuring filtering is neither too aggressive nor too permissive.

**Maintaining consistency**: The GAM model translates `max_cor` to an equivalent `max_vif`, so both filtering criteria work in harmony.

This approach was validated across 10,000 simulated datasets with varying correlation structures and predictor counts, consistently producing output VIF values in the 2–7 range while retaining informative predictors.

## When to Override

While the adaptive defaults work well for most cases, consider setting thresholds manually when:

- **Strict interpretability is required**: Set `max_vif = 2.5` or lower for inference-focused models where coefficient stability is critical.

- **Maximizing predictor retention**: Set `max_cor = 0.8` and `max_vif = 10` for prediction-focused models where some multicollinearity is acceptable.

- **Domain knowledge suggests specific thresholds**: When you know certain predictors should or shouldn't be retained together.

