---
title: "Adaptive Filtering Thresholds"
output: 
  rmarkdown::html_document:
    toc: true
    toc_title: "Content"
    source: false
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

## Summary

The function `collinear()` automatically configures multicollinearity filtering thresholds when the arguments `max_cor` and `max_vif` are not specified. 

This adaptive approach has several advantages:

- Eliminates the guesswork of choosing threshold values.
- Adapts filtering intensity to the correlation structure of the data.
- Keeps output VIF bounded within sensible limits (approximately 2.5 to 7.5).
- Allows manual override when specific thresholds are needed.

This approach was validated across 10,000 simulated datasets with varying correlation structures and predictor counts, consistently producing output VIF values in the 2–7 range while retaining informative predictors.

This article explains how the automatic threshold configuration works, demonstrates its effectiveness across varied datasets, and provides guidance on when manual configuration might be preferred.

## Setup

This article requires the following packages, setup, and example data.

```{r, message = FALSE, warning = FALSE, results = "hide"}
library(collinear)
library(future)
library(ggplot2)
library(patchwork)
library(rstudioapi)

#parallelization setup
#only useful for categorical predictors
future::plan(
  future::multisession,
  workers = future::availableCores() - 1
)

#progress bar (does not work in Rmarkdown)
#progressr::handlers(global = TRUE)

#example data
data(
  #dataframe with predictors
  vi_smol, 
  #vector of predictor names
  vi_predictors_numeric,
  #dataframes with experiment data
  experiment_adaptive_thresholds,
  experiment_cor_vs_vif,
  #pre-trained GAM model
  gam_cor_to_vif
  )
```


## Adaptive Threshold Selection

The arguments `max_cor` and `max_vif` define the maximum pairwise correlation and variance inflation factors allowed during multicollinearity filtering. 

Unlike `collinear_select()`, `cor_select()`, and `vif_select()`, which use fixed defaults (`max_cor = 0.7`, `max_vif = 5`), the function `collinear()` sets these to `NULL` and computes appropriate thresholds from the data.

Let's see how that works.

The vector [`vi_predictors_numeric`](reference/vi_predictors_numeric.html) names numeric predictors with a moderate multicollinearity, as the stats below show.

```{r}
collinear::collinear_stats(
  df = vi_smol,
  predictors = vi_predictors_numeric
) |> 
  dplyr::filter(
    statistic %in% c("quantile_0.75", "maximum")
  )
```

Notice that the VIF scores are very large! To fix this issue can run these predictors through `collinear()`.

```{r}
x <- collinear::collinear(
  df = vi_smol,
  predictors = vi_predictors_numeric
)
```

The first two messages above indicate the values of `max_cor` and `max_vif` selected by `collinear()` based on the data properties (more about that later). 

The last message indicates the predictors selected in this run. Their stats are shown below.

```{r}
collinear::collinear_stats(
  df = x$result$df,
  predictors = x$result$selection
) |> 
  dplyr::filter(
    statistic %in% c("quantile_0.75", "maximum")
  )
```

These stats show much more reasonable VIF scores now.

However, if you are aiming for specific multicollinearity thresholds, the automatic setup can be overriden by providing the desired values for `max_cor` and/or `max_vif`. If one of them is not defined, it will be ignored.

```{r}
x <- collinear::collinear(
  df = vi_smol,
  predictors = vi_predictors_numeric,
  max_cor = 0.5,
  max_vif = 2.5
)

collinear::collinear_stats(
  df = x$result$df,
  predictors = x$result$selection
) |> 
  dplyr::filter(
    statistic %in% c("quantile_0.75", "maximum")
  )
```

By adapting thresholds to each dataset's structure, `collinear()` provides sensible defaults while still allowing manual override when needed.

## Validation

To validate this adaptive threshold selection method I ran `collinear()` on 10,000 random subsets of a synthetic dataset with 500 columns and 10,000 rows generated using `distantia::zoo_simulate()`. Each iteration randomly selected 10-100 predictors and 30-100 rows per predictor, then compared input and output multicollinearity statistics.

The experiment script can be opened in RStudio as follows:

```{r, eval = FALSE}
system.file(
  "experiments/validation_adaptive_thresholds.R",
  package = "collinear"
  ) |> 
  rstudioapi::navigateToFile()
```

The results of this experiment are in the dataframe [`experiment_adaptive_thresholds`](reference/experiment_adaptive_thresholds.html), plotted below. 

```{r, echo = FALSE, fig.width=8, fig.height=3.5, echo = FALSE}
#left panel: shows output VIF across correlation structures
p1 <- ggplot2::ggplot(experiment_adaptive_thresholds) +
  ggplot2::aes(
    x = input_cor_q75,
    y = output_vif_max,
    color = input_predictors
  ) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::geom_hline(
    yintercept = 2.5, 
    linetype = "dashed", 
    color = "gray30"
    ) +
  ggplot2::geom_hline(
    yintercept = 7.5, 
    linetype = "dashed", 
    color = "gray30"
    ) +
  ggplot2::annotate(
    "text",
    x = min(experiment_adaptive_thresholds$input_cor_q75),
    y = 7.65,
    label = "VIF = 7.5",
    hjust = 0,
    size = 3.5,
    color = "gray30"
  ) +
  ggplot2::annotate(
    "text",
    x = min(experiment_adaptive_thresholds$input_cor_q75),
    y = 2.65,
    label = "VIF = 2.5",
    hjust = 0,
    size = 3.5,
    color = "gray30"
  ) +
  ggplot2::scale_color_viridis_c(option = "turbo") +
  ggplot2::scale_y_continuous(
    breaks = c(1, 2, 3, 4, 5, 6, 7, 8), 
    limits = c(1, 8)
    ) +
  ggplot2::labs(
    title = "Adaptive Threshold Effectiveness",
    x = "Input Correlation (quantile 0.75)",
    y = "Output Maximum VIF",
    color = "Input\nPredictors"
  ) +
  ggplot2::theme_bw()

#predictor retention: shows filtering scales reasonably with input size
p2 <- ggplot2::ggplot(experiment_adaptive_thresholds) +
  ggplot2::aes(
    x = input_predictors,
    y = output_predictors,
    color = output_vif_max
  ) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::geom_smooth(
    method = "gam",
    formula = y ~ s(x, k = 3),
    color = "gray30",
    se = TRUE
  ) +
  ggplot2::scale_color_viridis_c(option = "turbo") +
  ggplot2::scale_y_continuous(breaks = seq(0, 20, 5)) +
  ggplot2::labs(
    title = "Predictor Retention",
    x = "Input Predictors",
    y = "Selected Predictors",
    color = "Output\nmax VIF"
  ) +
  ggplot2::theme_bw()

#combined figure
p1 | p2
```

The left panel shows the 75th percentile of input correlation against the maximum VIF of the resulting selection. The cases below the VIF = 2.5 line (`r round((sum(experiment_adaptive_thresholds$output_vif_max < 2.5)/nrow(experiment_adaptive_thresholds))*100, 1)`% of all cases) are datasets with a small number of predictors where multicollinearity drops sharply when one or several key predictors are removed

The right panel shows the number of predictors before and after multicollinearity filtering. The sublinear relationship indicates that even with 100 input predictors, the selection stabilizes around 15-20 predictors.

These results indicate that the adaptive threshold selection works well across most use cases.


## Step By Step

The adaptive selection of multicollinearity thresholds requires three steps:

**1.** Compute the quantile 0.75 of the correlation for the input predictors via `cor_stats()`. This quantile is used because it captures the upper tail of the correlation distribution, where the problematic multicollinearity begins.

```{r}
cor_0.75 <- collinear::cor_stats(
  df = vi_smol,
  predictors = vi_predictors_numeric,
  quiet = TRUE
) |> 
  dplyr::filter(statistic == "quantile_0.75") |> 
  dplyr::pull(value)

cor_0.75
```

**2.** Sigmoid transformation of the `cor_0.75` value. This sigmoid function smoothly maps the input correlation to a bounded `max_cor` threshold.

```{r}
max_cor <- 0.493 + 0.242 / (1 + exp(-15 * (cor_0.75 - 0.614)))

max_cor
```

Where:

 - `0.493`: floor of the curve, corresponding to VIF ≈ 2.5 in `prediction_cor_to_vif` (conservative filtering).
 - `0.735`: ceiling of the curve (0.545 + 0.24), corresponding to VIF ≈ 7.5 in `prediction_cor_to_vif` (permissive filtering).
 - `0.614`: midpoint where the transition is steepest.
 - `-15`: steepness parameter controlling how sharply the curve transitions.
 
The full sigmoid curve is shown below.

```{r, echo = FALSE, fig.width=6, fig.height=3.5, echo = FALSE}
sigmoid_df <- data.frame(
  cor_input = seq(0, 1, by = 0.01)
) |>
  dplyr::mutate(
    max_cor = 0.493 + 0.242 / (1 + exp(-15 * (cor_input - 0.614)))
  )

ggplot2::ggplot(sigmoid_df) +
  ggplot2::aes(x = cor_input, y = max_cor) +
  ggplot2::geom_line(linewidth = 1, color = "red4") +
  ggplot2::geom_hline(yintercept = c(0.493, 0.735), linetype = "dashed", alpha = 0.5) +
  ggplot2::geom_vline(xintercept = 0.614, linetype = "dotted", alpha = 0.5) +
  ggplot2::labs(
    title = "Sigmoid Transformation",
    x = "Input Correlation (quantile 0.75)",
    y = "Adaptive Correlation Threshold"
  ) +
  ggplot2::annotate("text", x = 0.80, y = 0.493 + 0.015, label = "floor (VIF ≈ 2.5)", size = 3) +
  ggplot2::annotate("text", x = 0.15, y = 0.735 - 0.015, label = "ceiling (VIF ≈ 7.5)", size = 3) +
  ggplot2::theme_bw()
```

Datasets with low correlation (quantile 0.75 < 0.5) receive thresholds near the floor, while highly correlated datasets (quantile 0.75 > 0.8) approach the ceiling. This prevents both over-filtering of clean datasets and under-filtering of problematic ones.

3. The pre-trained GAM model [`gam_cor_to_vif`](reference/gam_cor_to_vif.html) predicts a suitable `max_vif` from the `max_cor` resulting from the transformation.

```{r}
max_vif <- mgcv::predict.gam(
  object = collinear::gam_cor_to_vif,
  newdata = data.frame(max_cor = max_cor)
) 

max_vif
```

This model was fitted on the simulation results in [`experiment_cor_vs_vif`](reference/experiment_cor_vs_vif.html), where both filtering methods were applied across 10,000 random dataset configurations. For each `max_cor` value, the `max_vif` producing the highest Jaccard similarity between the two selections was identified.

The experiment script can be opened in RStudio as follows:

```{r, eval = FALSE}
system.file(
  "experiments/relationship_cor_vs_vif.R",
  package = "collinear"
) |> 
  rstudioapi::navigateToFile()
```

The model uses squared Jaccard similarity as weights to emphasize cases where `cor_select()` and `vif_select()` achieved strong agreement.

```{r, eval = FALSE}
m <- mgcv::gam(
  formula = max_vif ~ s(max_cor, k = 6),
  weights = experiment_cor_vs_vif$out_selection_jaccard^2,
  data = experiment_cor_vs_vif
)
```

The plot below shows the simulation results and the fitted model.

```{r, echo = FALSE, fig.width=7, fig.height=3.5, echo = FALSE}
collinear::experiment_cor_vs_vif |> 
  dplyr::arrange(
    out_selection_jaccard
  ) |> 
ggplot2::ggplot() + 
  ggplot2::aes(
    x = max_cor,
    y = max_vif,
    color = out_selection_jaccard,
    weight = out_selection_jaccard^3
  ) + 
  ggplot2::geom_point(alpha = 0.5) + 
  ggplot2::geom_smooth(
    method = "gam",
    formula = y ~ s(x, k = 9),
    method.args = list(
      select = TRUE
    ),
    color = "black",
    se = TRUE
  ) +
  ggplot2::scale_color_viridis_c(
    option = "turbo", 
    direction = 1
    ) + 
  ggplot2::labs(
    x = "Input max_cor",
    y = "Equivalent max_vif Threshold",
    color = "Jaccard\nSimilarity"
  ) + 
  ggplot2::theme_bw()
```


The curve tracks through the high-similarity region (red/orange points), indicating that the model successfully captures the relationship between `max_cor` and `max_vif` for cases where both methods agree.

## When to Override

While the adaptive defaults work well for most cases, consider setting thresholds manually when:

- **Strict coefficient interpretability is required**: Set `max_vif = 2.5` or lower for models where coefficient stability is critical.

- **Maximizing predictor retention**: Set `max_cor = 0.9` and `max_vif = 10` for prediction-focused models where some multicollinearity is acceptable.

- **Domain-specific requirements**: Some fields have established VIF thresholds (e.g., VIF < 5 or VIF < 10) that should be used for consistency with existing literature.

```{r, include = FALSE}
#reset parallelization
future::plan(future::sequential)
```

