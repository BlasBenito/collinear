---
title: "Adaptive Filtering Thresholds"
output: 
  rmarkdown::html_document:
    toc: true
    toc_title: "Content"
    source: false
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

## Summary

The `collinear` package automatically configures multicollinearity filtering thresholds when users don't specify them explicitly. This adaptive approach:

- Eliminates the guesswork of choosing appropriate `max_cor` and `max_vif` values
- Adapts to each dataset's correlation structure
- Ensures alignment between correlation and VIF thresholds
- Maintains a minimum filtering level even for datasets with low multicollinearity

This article explains how the automatic threshold configuration works and when to use it versus manual configuration.

## Required Libraries

```{r}
library(collinear)
library(ggplot2)
```

## How Automatic Configuration Works

When both `max_cor` and `max_vif` are `NULL` (the default), `collinear()` follows a three-step process:

### Step 1: Assess Dataset Multicollinearity

The function computes the correlation matrix and its statistics:

```{r, include = FALSE}
data(vi_smol, vi_predictors)
```

```{r}
# Compute correlation statistics
cor_statistics <- collinear::cor_stats(
  df = vi_smol,
  predictors = vi_predictors,
  quiet = TRUE
)

cor_statistics
```

The median correlation provides a robust indicator of the overall multicollinearity level in the dataset.

### Step 2: Configure max_cor

The `max_cor` threshold is set as:

```r
max_cor <- max(0.58, round(median_correlation, 2))
```

This formula ensures:

- **Data-driven**: Uses the dataset's median correlation as baseline
- **Minimum threshold**: The floor of 0.58 (approximately matching VIF = 2.5) prevents overly permissive filtering
- **Rounded**: Two decimal places for interpretability

Let's see this in action:

```{r}
# Extract median correlation
median_cor <- cor_statistics[
  cor_statistics$statistic == "median",
  "value"
]

# Compute max_cor as collinear() does
max_cor_auto <- max(0.58, round(median_cor, 2))

cat("Median correlation:", median_cor, "\n")
cat("Automatic max_cor:", max_cor_auto, "\n")
```

### Step 3: Configure max_vif

Once `max_cor` is determined, `max_vif` is computed using a pre-trained GAM model that establishes the equivalence between correlation and VIF thresholds:

```{r}
# Predict matching VIF threshold
max_vif_auto <- mgcv::predict.gam(
  object = collinear::gam_cor_to_vif,
  newdata = data.frame(max_cor = max_cor_auto)
) |>
  round(2)

cat("Automatic max_vif:", max_vif_auto, "\n")
```

This ensures that the correlation and VIF filtering strategies are aligned and complementary.

## The Correlation-VIF Equivalence Model

The relationship between `max_cor` and `max_vif` is based on extensive simulations stored in the dataset `experiment_cor_vs_vif`. The GAM model `gam_cor_to_vif` captures this relationship:

```{r, fig.width=7, fig.height=5}
# Load the equivalence data
data(equivalence_cor_vif)

# Visualize the relationship
ggplot2::ggplot(equivalence_cor_vif) +
  ggplot2::aes(x = max_cor, y = max_vif) +
  ggplot2::geom_line(color = "steelblue", linewidth = 1) +
  ggplot2::geom_point(
    data = data.frame(
      max_cor = max_cor_auto,
      max_vif = max_vif_auto
    ),
    color = "red",
    size = 3
  ) +
  ggplot2::labs(
    x = "Maximum Correlation Threshold",
    y = "Maximum VIF Threshold",
    title = "Correlation-VIF Equivalence",
    subtitle = "Red point shows auto-configured thresholds for vi_smol dataset"
  ) +
  ggplot2::theme_bw()
```

The red point shows where our example dataset falls on this curve. Datasets with higher median correlation receive higher thresholds, while those with lower correlation get more conservative thresholds (but never below 0.58).

## Practical Examples

### Example 1: Automatic Configuration (Default)

When you don't specify thresholds, `collinear()` configures them automatically:

```{r}
result_auto <- collinear::collinear(
  df = vi_smol,
  response = "vi_numeric",
  predictors = vi_predictors,
  quiet = FALSE  # Show messages about automatic configuration
)
```

The function messages inform you of the chosen thresholds. These adapt to your specific dataset's correlation structure.

### Example 2: Manual Configuration

You can override automatic configuration by specifying one or both thresholds:

```{r}
# Specify only max_cor (max_vif is ignored, not auto-configured)
result_cor_only <- collinear::collinear(
  df = vi_smol,
  response = "vi_numeric",
  predictors = vi_predictors,
  max_cor = 0.7,
  quiet = TRUE
)

# Specify both thresholds
result_manual <- collinear::collinear(
  df = vi_smol,
  response = "vi_numeric",
  predictors = vi_predictors,
  max_cor = 0.7,
  max_vif = 5,
  quiet = TRUE
)
```

### Example 3: High vs. Low Multicollinearity Datasets

Let's compare how automatic configuration adapts to datasets with different multicollinearity levels:

```{r}
# Simulate low multicollinearity dataset
set.seed(123)
n <- 1000
df_low <- data.frame(
  y = rnorm(n),
  x1 = rnorm(n),
  x2 = rnorm(n),
  x3 = rnorm(n),
  x4 = rnorm(n)
)

# Check median correlation
cor_low <- collinear::cor_stats(
  df = df_low,
  predictors = c("x1", "x2", "x3", "x4"),
  quiet = TRUE
)

median_cor_low <- cor_low[cor_low$statistic == "median", "value"]

cat("Low multicollinearity dataset:\n")
cat("  Median correlation:", round(median_cor_low, 3), "\n")
cat("  Auto max_cor:", max(0.58, round(median_cor_low, 2)), "\n\n")

# Simulate high multicollinearity dataset
df_high <- data.frame(
  y = rnorm(n),
  x1 = rnorm(n)
)
df_high$x2 <- df_high$x1 + rnorm(n, sd = 0.3)
df_high$x3 <- df_high$x1 + rnorm(n, sd = 0.3)
df_high$x4 <- df_high$x2 + rnorm(n, sd = 0.3)

# Check median correlation
cor_high <- collinear::cor_stats(
  df = df_high,
  predictors = c("x1", "x2", "x3", "x4"),
  quiet = TRUE
)

median_cor_high <- cor_high[cor_high$statistic == "median", "value"]

cat("High multicollinearity dataset:\n")
cat("  Median correlation:", round(median_cor_high, 3), "\n")
cat("  Auto max_cor:", max(0.58, round(median_cor_high, 2)), "\n")
```

Notice how the low multicollinearity dataset gets the minimum threshold (0.58), while the high multicollinearity dataset receives a more permissive threshold adapted to its correlation structure.

## Comparison of Filtering Results

Let's examine how automatic versus manual configuration affects the final selection:

```{r}
# Get selections from different approaches
selection_auto <- result_auto$vi_numeric$selection
selection_manual <- result_manual$selection

cat("Automatic configuration:\n")
cat("  Selected predictors:", length(selection_auto), "\n")
cat("  Thresholds: max_cor =", max_cor_auto, ", max_vif =", max_vif_auto, "\n\n")

cat("Manual configuration:\n")
cat("  Selected predictors:", length(selection_manual), "\n")
cat("  Thresholds: max_cor = 0.7, max_vif = 5\n")
```

We can visualize the overlap between selections:

```{r, fig.width=7, fig.height=5}
# Create comparison data
comparison <- data.frame(
  predictor = unique(c(selection_auto, selection_manual)),
  auto = NA,
  manual = NA
)

comparison$auto <- ifelse(comparison$predictor %in% selection_auto, "Selected", "Not Selected")
comparison$manual <- ifelse(comparison$predictor %in% selection_manual, "Selected", "Not Selected")

# Count agreement
both_selected <- sum(comparison$auto == "Selected" & comparison$manual == "Selected")
only_auto <- sum(comparison$auto == "Selected" & comparison$manual == "Not Selected")
only_manual <- sum(comparison$auto == "Not Selected" & comparison$manual == "Selected")

cat("\nSelection agreement:\n")
cat("  Both methods:", both_selected, "\n")
cat("  Only automatic:", only_auto, "\n")
cat("  Only manual:", only_manual, "\n")
```

## When to Use Automatic vs. Manual Configuration

### Use Automatic Configuration When:

1. **Exploratory analysis**: You're getting familiar with a new dataset
2. **No domain knowledge**: You don't have strong priors about appropriate thresholds
3. **Multiple datasets**: You're applying the same analysis to datasets with varying correlation structures
4. **Reproducibility**: You want filtering criteria that adapt to data changes

### Use Manual Configuration When:

1. **Specific requirements**: Your field has established threshold conventions
2. **Regulatory compliance**: Your analysis must meet predetermined criteria
3. **Comparative studies**: You need consistent thresholds across multiple analyses
4. **Fine-tuning**: You want more or less aggressive filtering than automatic configuration provides

## Best Practices

1. **Start with automatic**: Begin with automatic configuration to understand your data's natural threshold
2. **Inspect the results**: Check the selected predictors and multicollinearity statistics
3. **Adjust if needed**: Use manual configuration if automatic thresholds don't meet your needs
4. **Document your choice**: Always note whether you used automatic or manual configuration in your analysis

## Performance Testing

The automatic configuration approach has been validated through extensive simulations (see `experiment_collinear_auto`):

```{r}
data(experiment_collinear_auto)

# Summary of reduction in predictors
reduction <- (experiment_collinear_auto$input_predictors - 
              experiment_collinear_auto$output_predictors) / 
             experiment_collinear_auto$input_predictors * 100

cat("Simulation results (n =", nrow(experiment_collinear_auto), "experiments):\n")
cat("  Mean predictor reduction:", round(mean(reduction), 1), "%\n")
cat("  Mean output max VIF:", round(mean(experiment_collinear_auto$output_vif_max), 2), "\n")
cat("  Mean output median correlation:", round(mean(experiment_collinear_auto$output_cor_median), 2), "\n")
```

These results demonstrate that automatic configuration consistently produces selections with low multicollinearity while retaining a substantial proportion of the original predictors.

## Recommendations

1. **Default behavior**: Trust the automatic configuration for most analyses. It's designed to work well across a wide range of datasets.

2. **Monitor messages**: Pay attention to the messages showing auto-configured thresholds. If they seem unusual for your data, investigate further.

3. **Check outputs**: Always inspect the resulting VIF scores and correlations using `vif_df()` or `cor_df()` to ensure the filtering meets your needs.

4. **Iterate if needed**: If automatic configuration is too aggressive or too permissive, switch to manual configuration with appropriate thresholds.

5. **Document your approach**: Whether using automatic or manual configuration, document your choice and reasoning for reproducibility.

## Summary

The adaptive filtering threshold feature in `collinear`:

- Eliminates guesswork by analyzing each dataset's correlation structure
- Uses a validated correlation-VIF equivalence model
- Maintains minimum filtering standards (max_cor â‰¥ 0.58)
- Provides flexibility through manual override options
- Has been tested across thousands of simulated scenarios

This approach makes multicollinearity management more accessible while maintaining statistical rigor, allowing researchers to focus on interpretation rather than threshold selection.

```{r cleanup, include=FALSE}
# Reset any settings if needed
```
