[{"path":"https://blasbenito.github.io/collinear/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Blas M. Benito Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/adaptive_filtering_thresholds.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Adaptive Filtering Thresholds","text":"function collinear() automatically configures multicollinearity filtering thresholds arguments max_cor max_vif specified. adaptive approach several advantages: Eliminates guesswork choosing threshold values. Adapts filtering intensity correlation structure data. Keeps output VIF bounded within sensible limits (approximately 2.5 7.5). Allows manual override specific thresholds needed. approach validated across 10,000 simulated datasets varying correlation structures predictor counts, consistently producing output VIF values 2–7 range retaining informative predictors. article explains automatic threshold configuration works, demonstrates effectiveness across varied datasets, provides guidance manual configuration might preferred.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/adaptive_filtering_thresholds.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Adaptive Filtering Thresholds","text":"article requires following packages, setup, example data.","code":"library(collinear) library(future) library(ggplot2) library(patchwork) library(rstudioapi)  #parallelization setup #only useful for categorical predictors future::plan(   future::multisession,   workers = future::availableCores() - 1 )  #progress bar (does not work in Rmarkdown) #progressr::handlers(global = TRUE)  #example data data(   #dataframe with predictors   vi_smol,    #vector of predictor names   vi_predictors_numeric,   #dataframes with experiment data   experiment_adaptive_thresholds,   experiment_cor_vs_vif,   #pre-trained GAM model   gam_cor_to_vif   )"},{"path":"https://blasbenito.github.io/collinear/articles/adaptive_filtering_thresholds.html","id":"adaptive-threshold-selection","dir":"Articles","previous_headings":"","what":"Adaptive Threshold Selection","title":"Adaptive Filtering Thresholds","text":"arguments max_cor max_vif define maximum pairwise correlation variance inflation factors allowed multicollinearity filtering. Unlike collinear_select(), cor_select(), vif_select(), use fixed defaults (max_cor = 0.7, max_vif = 5), function collinear() sets NULL computes appropriate thresholds data. Let’s see works. vector vi_predictors_numeric names numeric predictors moderate multicollinearity, stats show. Notice VIF scores large! fix issue can run predictors collinear(). first two messages indicate values max_cor max_vif selected collinear() based data properties (later). last message indicates predictors selected run. stats shown . stats show much reasonable VIF scores now. However, aiming specific multicollinearity thresholds, automatic setup can overriden providing desired values max_cor /max_vif. one defined, ignored. adapting thresholds dataset’s structure, collinear() provides sensible defaults still allowing manual override needed.","code":"collinear::collinear_stats(   df = vi_smol,   predictors = vi_predictors_numeric ) |>    dplyr::filter(     statistic %in% c(\"quantile_0.75\", \"maximum\")   ) #>        method     statistic    value #> 1 correlation quantile_0.75   0.6184 #> 2 correlation       maximum   0.9893 #> 3         vif quantile_0.75 354.2920 #> 4         vif       maximum 553.2944 x <- collinear::collinear(   df = vi_smol,   predictors = vi_predictors_numeric ) #>  #> collinear::collinear(): setting 'max_cor' to 0.618. #>  #> collinear::collinear(): setting 'max_vif' to 5.0318. #>  #> collinear::collinear() #> └── collinear::validate_arg_preference_order() #>     └── collinear::preference_order(): ranking 47 'predictors' from lower to higher multicollinearity. #>  #> collinear::collinear(): selected predictors:  #>  - topo_elevation #>  - topo_slope #>  - humidity_range #>  - topo_diversity #>  - soil_clay #>  - cloud_cover_range #>  - soil_silt #>  - rainfall_min #>  - growing_season_temperature #>  - swi_max #>  - soil_nitrogen #>  - temperature_seasonality #>  - rainfall_max collinear::collinear_stats(   df = x$result$df,   predictors = x$result$selection ) |>    dplyr::filter(     statistic %in% c(\"quantile_0.75\", \"maximum\")   ) #>        method     statistic  value #> 1 correlation quantile_0.75 0.3342 #> 2 correlation       maximum 0.6109 #> 3         vif quantile_0.75 2.4148 #> 4         vif       maximum 3.4733 x <- collinear::collinear(   df = vi_smol,   predictors = vi_predictors_numeric,   max_cor = 0.5,   max_vif = 2.5 ) #>  #> collinear::collinear() #> └── collinear::validate_arg_preference_order() #>     └── collinear::preference_order(): ranking 47 'predictors' from lower to higher multicollinearity. #>  #> collinear::collinear(): selected predictors:  #>  - topo_elevation #>  - topo_slope #>  - humidity_range #>  - soil_clay #>  - cloud_cover_range #>  - soil_silt #>  - rainfall_min #>  - growing_season_temperature #>  - swi_max #>  - soil_nitrogen  collinear::collinear_stats(   df = x$result$df,   predictors = x$result$selection ) |>    dplyr::filter(     statistic %in% c(\"quantile_0.75\", \"maximum\")   ) #>        method     statistic  value #> 1 correlation quantile_0.75 0.2926 #> 2 correlation       maximum 0.4573 #> 3         vif quantile_0.75 1.8224 #> 4         vif       maximum 2.1159"},{"path":"https://blasbenito.github.io/collinear/articles/adaptive_filtering_thresholds.html","id":"validation","dir":"Articles","previous_headings":"","what":"Validation","title":"Adaptive Filtering Thresholds","text":"validate adaptive threshold selection method ran collinear() 10,000 random subsets synthetic dataset 500 columns 10,000 rows generated using distantia::zoo_simulate(). iteration randomly selected 10-100 predictors 30-100 rows per predictor, compared input output multicollinearity statistics. experiment script can opened RStudio follows: results experiment dataframe experiment_adaptive_thresholds, plotted .  left panel shows 75th percentile input correlation maximum VIF resulting selection. cases VIF = 2.5 line (4% cases) datasets small number predictors multicollinearity drops sharply one several key predictors removed right panel shows number predictors multicollinearity filtering. sublinear relationship indicates even 100 input predictors, selection stabilizes around 15-20 predictors. results indicate adaptive threshold selection works well across use cases.","code":"system.file(   \"experiments/validation_adaptive_thresholds.R\",   package = \"collinear\"   ) |>    rstudioapi::navigateToFile()"},{"path":"https://blasbenito.github.io/collinear/articles/adaptive_filtering_thresholds.html","id":"step-by-step","dir":"Articles","previous_headings":"","what":"Step By Step","title":"Adaptive Filtering Thresholds","text":"adaptive selection multicollinearity thresholds requires three steps: 1. Compute quantile 0.75 correlation input predictors via cor_stats(). quantile used captures upper tail correlation distribution, problematic multicollinearity begins. 2. Sigmoid transformation cor_0.75 value. sigmoid function smoothly maps input correlation bounded max_cor threshold. : 0.493: floor curve, corresponding VIF ≈ 2.5 prediction_cor_to_vif (conservative filtering). 0.735: ceiling curve (0.545 + 0.24), corresponding VIF ≈ 7.5 prediction_cor_to_vif (permissive filtering). 0.614: midpoint transition steepest. -15: steepness parameter controlling sharply curve transitions. full sigmoid curve shown .  Datasets low correlation (quantile 0.75 < 0.5) receive thresholds near floor, highly correlated datasets (quantile 0.75 > 0.8) approach ceiling. prevents -filtering clean datasets -filtering problematic ones. pre-trained GAM model gam_cor_to_vif predicts suitable max_vif max_cor resulting transformation. model fitted simulation results experiment_cor_vs_vif, filtering methods applied across 10,000 random dataset configurations. max_cor value, max_vif producing highest Jaccard similarity two selections identified. experiment script can opened RStudio follows: model uses squared Jaccard similarity weights emphasize cases cor_select() vif_select() achieved strong agreement. plot shows simulation results fitted model.  curve tracks high-similarity region (red/orange points), indicating model successfully captures relationship max_cor max_vif cases methods agree.","code":"cor_0.75 <- collinear::cor_stats(   df = vi_smol,   predictors = vi_predictors_numeric,   quiet = TRUE ) |>    dplyr::filter(statistic == \"quantile_0.75\") |>    dplyr::pull(value)  cor_0.75 #> [1] 0.6184 max_cor <- 0.493 + 0.242 / (1 + exp(-15 * (cor_0.75 - 0.614)))  max_cor #> [1] 0.6179916 max_vif <- mgcv::predict.gam(   object = collinear::gam_cor_to_vif,   newdata = data.frame(max_cor = max_cor) )   max_vif #>        1  #> 5.031596 system.file(   \"experiments/relationship_cor_vs_vif.R\",   package = \"collinear\" ) |>    rstudioapi::navigateToFile() m <- mgcv::gam(   formula = max_vif ~ s(max_cor, k = 6),   weights = experiment_cor_vs_vif$out_selection_jaccard^2,   data = experiment_cor_vs_vif )"},{"path":"https://blasbenito.github.io/collinear/articles/adaptive_filtering_thresholds.html","id":"when-to-override","dir":"Articles","previous_headings":"","what":"When to Override","title":"Adaptive Filtering Thresholds","text":"adaptive defaults work well cases, consider setting thresholds manually : Strict coefficient interpretability required: Set max_vif = 2.5 lower models coefficient stability critical. Maximizing predictor retention: Set max_cor = 0.9 max_vif = 10 prediction-focused models multicollinearity acceptable. Domain-specific requirements: fields established VIF thresholds (e.g., VIF < 5 VIF < 10) used consistency existing literature.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/collinear_in_the_wild.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"collinear In The Wild","text":"article lists mentions citations R package collinear. #2024 Simons, . L., Baez, H., Acharya-Patel, N., Helbing, C. C., Jeffers, J., Stanford, J., & Meyer, R. S. (2024). TerraDactyl: tool connecting environmental data . Ecological Informatics, 102974. https://doi.org/10.1016/j.ecoinf.2024.102974","code":""},{"path":"https://blasbenito.github.io/collinear/articles/dual_filtering_strategy.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Dual Filtering Strategy","text":"function collinear_select() applies two complementary methods assess different aspects multicollinearity: Pairwise correlation (Pearson /Cramer’s V): identifies pairs highly redundant variables. Variance Inflation Factors: measures much variance regression coefficient inflated due multicollinearity predictors. combining pairwise method (correlation) multivariate one (VIF), collinear_select() able capture multicollinearity either method alone might miss. time, respects predictor rankings protect relevant variables filtering. article explains dual filtering algorithm works, demonstrates behavior examples, provides guidance use filtering method.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/dual_filtering_strategy.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Dual Filtering Strategy","text":"examples herein require following setup.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/dual_filtering_strategy.html","id":"the-multicollinearity-filtering-algorithm","dir":"Articles","previous_headings":"","what":"The Multicollinearity Filtering Algorithm","title":"Dual Filtering Strategy","text":"filtering algorithm collinear_select() works follows: Predictors ranked according argument preference_order, lower higher overall multicollinearity otherwise. correlation matrix predictors computed cor_matrix(). first predictor ranking selected, others candidates. candidates evaluated sequentially: 4a. max_cor set, maximum correlation candidate selected higher max_cor, candidate discarded algorithm moves next one. Otherwise, candidate goes next step. 4b. max_vif set, maximum VIF candidate selected predictors higher max_vif, candidate discarded. Otherwise, candidate selected, algorithm moves next candidate. finalize, selected predictors returned. Let’s take look works code multicollinearity thresholds predictors . simplify code bit, predictors already ordered preference, omit cases max_vif = NULL max_cor = NULL. correlation matrix computed cor_matrix() ordered argument preference_order. first predictor preference_order added selected remaining ones go candidates. first candidate gets ready evaluation. maximum correlation selected candidate assessed extracting selected rows candidate column absolute correlation matrix, computing maximum, comparing max_cor. expression evaluates TRUE, candidate removed candidates, candidates <- candidates[-1], new candidate selected evaluation. Otherwise algorithm moves VIF evaluation. subset m rows columns selected candidate used input vif(). evaluates TRUE, candidate rejected algorithm goes next candidate. Otherwise, candidate added selected removed candidates, new candidate selected evaluation. Let’s take look whole loop: Let’s see collinear_select() returns selection. multicollinearity filtering works within collinear!","code":"max_vif = 5 max_cor = 0.7  predictors <- c(   \"swi_mean\",   \"soil_temperature_mean\",    \"rainfall_mean\",   \"growing_season_length\" ) m <- collinear::cor_matrix(   df = vi_smol,   predictors = predictors,   quiet = TRUE )  m <- m[   predictors,    predictors   ]  round(m, 2) #>                       swi_mean soil_temperature_mean rainfall_mean #> swi_mean                  1.00                 -0.19          0.66 #> soil_temperature_mean    -0.19                  1.00          0.05 #> rainfall_mean             0.66                  0.05          1.00 #> growing_season_length     0.88                 -0.07          0.78 #>                       growing_season_length #> swi_mean                               0.88 #> soil_temperature_mean                 -0.07 #> rainfall_mean                          0.78 #> growing_season_length                  1.00 selected <- predictors[1] candidates <- predictors[-1] candidate <- candidates[1] max(   abs(     m[       selected,        candidate       ]     )   ) > max_cor #> [1] FALSE max(   collinear::vif(     m = m[       c(selected, candidate),       c(selected, candidate)     ]   ) ) > max_vif #> [1] FALSE selected <- c(selected, candidate) candidates <- candidates[-1] candidate <- candidates[1] #compute and reorder correlation matrix m <- collinear::cor_matrix(   df = vi_smol,   predictors = predictors,   quiet = TRUE )  m <- m[   predictors,   predictors ]  #generate selected and candidates selected <- predictors[1] candidates <- predictors[-1]  #iterate over candidates for (candidate in candidates) {      #correlation   if (     max(       abs(         m[           selected,           candidate         ]       )     ) > max_cor   ) {     #if TRUE move to next candidate     next   }    #vif evaluation   if (     max(       vif(         m[           c(selected, candidate),           c(selected, candidate)         ]       )     ) > max_vif   ) {     #if TRUE, move to next candidate     next   }    selected <- c(selected, candidate)    }  selected #> [1] \"swi_mean\"              \"soil_temperature_mean\" \"rainfall_mean\" collinear::collinear_select(   df = vi_smol,   predictors = predictors,   preference_order = predictors,   max_cor = 0.7,   max_vif = 5 ) #> [1] \"swi_mean\"              \"soil_temperature_mean\" \"rainfall_mean\"         #> attr(,\"validated\") #> [1] TRUE"},{"path":"https://blasbenito.github.io/collinear/articles/intelligent_predictor_ranking.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Intelligent Predictor Ranking","text":"package collinear implements automated multicollinearity filtering method devised preserve many relevant predictors possible. principle helps balance multicollinearity reduction predictive power retention. feature implemented collinear(), collinear_select(), vif_select() cor_select() via argument preference_order. argument allows representing predictor relevance three ways: Expert Mode: Vector predictor names ordered left right according user’s preference. option helps collinear() get domain expertise account, lets user focus specific predictors. Intelligent Predictor Ranking: functionality, implemented preference_order(), prioritizes predictors univariate association response ensure relevant ones retained multicollinearity filtering. option maximizes predictive power filtered predictors. Naive Option: none options used, collinear() ranks predictors lower higher collinearity predictors. option preserves less redundant predictors, might lead robust models. options explained detail following sections.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/intelligent_predictor_ranking.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Intelligent Predictor Ranking","text":"article requires following setup.","code":"library(collinear) library(future) library(DT)  #parallelization setup #only useful for categorical predictors future::plan(   future::multisession,   workers = future::availableCores() - 1 )  #progress bar (does not work in Rmarkdown) #progressr::handlers(global = TRUE)  #example data data(vi_smol, vi_predictors_numeric)"},{"path":"https://blasbenito.github.io/collinear/articles/intelligent_predictor_ranking.html","id":"expert-mode","dir":"Articles","previous_headings":"","what":"Expert Mode","title":"Intelligent Predictor Ranking","text":"Let’s consider little hypothetical. user dataframe x three variables , b c, domain knowledge indicating b key preserved possible. , user calls collinear() follows: Notice argument responses missing: option ignores , making response variable entirely optional. happens ?: : Selected. b: Selected correlation \"\" <= 0.5, filtered away otherwise. c: Selected maximum correlation b <= 0.5, filtered away otherwise. summary, first predictor preference_order always selected, ones selected rejected conditionally collinearity already selected ones. case wonder: predictors preference_order ranked lower higher collinearity among , added order preference vector. Let’s take look tangible case now. code calls collinear() dataset vi_smol, contains numeric response vi_numeric (values vegetation index) bunch numeric predictors named vector vi_predictors_numeric. Let’s say ’d like focus analysis limiting role soil water content (variables swi_xxx, soil water index) controlling vi_numeric. case, can call collinear() follows: Notice swi_min swi_range selected, swi_max swi_mean removed collinear swi_min. said , predictors argument preference_order ranked lower higher mutual collinearity. Now can quickly fit quick exploratory model, save R-squared later.","code":"y <- collinear::collinear(   df = x,   predictors = c(\"a\", \"b\", \"c\"),   preference_order = c(\"a\", \"b\"),   max_cor = 0.5 ) y <- collinear::collinear(   df = vi_smol,   response = \"vi_numeric\",   predictors = vi_predictors_numeric,   preference_order = c(     \"swi_min\",     \"swi_max\",     \"swi_mean\",     \"swi_range\"   ),   max_cor = 0.5,   max_vif = 2.5,   quiet = TRUE )  y$vi_numeric$selection #> [1] \"swi_min\"                    \"swi_range\"                  #> [3] \"topo_elevation\"             \"topo_slope\"                 #> [5] \"humidity_range\"             \"soil_clay\"                  #> [7] \"soil_silt\"                  \"rainfall_min\"               #> [9] \"growing_season_temperature\" #> attr(,\"validated\") #> [1] TRUE m1 <- stats::lm(   formula = y$vi_numeric$formulas$linear,   data = y$vi_numeric$df ) |>    summary()  m1 #>  #> Call: #> stats::lm(formula = y$vi_numeric$formulas$linear, data = y$vi_numeric$df) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.42802 -0.06894 -0.00307  0.07331  0.32260  #>  #> Coefficients: #>                              Estimate Std. Error t value Pr(>|t|)     #> (Intercept)                 1.261e-02  3.004e-02   0.420  0.67490     #> swi_min                     5.591e-03  4.769e-04  11.723  < 2e-16 *** #> swi_range                   7.739e-03  3.072e-04  25.191  < 2e-16 *** #> topo_elevation             -2.709e-05  8.601e-06  -3.149  0.00172 **  #> topo_slope                  7.592e-03  1.551e-03   4.895 1.26e-06 *** #> humidity_range             -8.134e-03  7.503e-04 -10.840  < 2e-16 *** #> soil_clay                   1.120e-03  6.266e-04   1.788  0.07433 .   #> soil_silt                  -1.257e-03  4.987e-04  -2.520  0.01200 *   #> rainfall_min                7.244e-04  1.008e-04   7.190 1.94e-12 *** #> growing_season_temperature  3.418e-03  8.626e-04   3.963 8.29e-05 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.1079 on 600 degrees of freedom #> Multiple R-squared:  0.7418, Adjusted R-squared:  0.7379  #> F-statistic: 191.5 on 9 and 600 DF,  p-value: < 2.2e-16"},{"path":"https://blasbenito.github.io/collinear/articles/intelligent_predictor_ranking.html","id":"intelligent-predictor-ranking","dir":"Articles","previous_headings":"","what":"Intelligent Predictor Ranking","title":"Intelligent Predictor Ranking","text":"Let’s go back little hypothetical dataframe x, three variables , b c. time also response y, user much domain knowledge ’d like (happens, ’ve seen ). case, collinear first fits univariate models y ~ , y ~ b, y ~ c, computes R-squared observations model predictions, ranks predictors best worse according metric. functionality implemented function preference_order(), can take advantage parallelization backend speed-operations. Let’s take look works, step step. Let start simplest approach. function returns dataframe predictors ordered better worse modelling performance response. column f indicates name function used fit univariate models, f_numeric_glm() case. function selected automatically argument f preference_order() set f_auto default (f functions must parenthesis calling via f argument). function looks types responses predictors, select one functions returned f_functions() perform operation. Let’s talk later, now, can plug preference order dataframe directly collinear(). , can use collinear() output fit little model. compare R-squared two models created far, can see preference_order() helps balance aggressive multicollinearity filtering robust modelling outcomes. Let’s go back f_auto() moment. function looks input data assess type response predictors, looks dataframe choose function. can see action across different settings . f_...() functions available usage preference_order() listed dataframe returned f_functions(). know way around functions, can choose one prefer case. example, replace f_auto f_numeric_gam fit univariate GAM models. gentle reminder finish section: collinear() runs preference_order() internally preference_order = NULL argument f receives valid function. like preference_order(), can use cross-validation assess association response predictor robust manner. output preference_order() returned collinear().","code":"x <- collinear::preference_order(   df = vi_smol,   responses = \"vi_numeric\",   predictors = vi_predictors_numeric,   quiet = TRUE ) y <- collinear::collinear(   df = vi_smol,   response = \"vi_numeric\",   predictors = vi_predictors_numeric,   preference_order = x,   max_cor = 0.5,   max_vif = 2.5,   quiet = TRUE )  y$vi_numeric$selection #> [1] \"growing_season_length\" \"swi_min\"               \"rainfall_min\"          #> [4] \"solar_rad_range\"       \"cloud_cover_range\"     \"soil_clay\"             #> [7] \"topo_diversity\"        \"soil_silt\"             #> attr(,\"validated\") #> [1] TRUE m2 <- stats::lm(   formula = y$vi_numeric$formulas$linear,   data = y$vi_numeric$df ) |>    summary()  m2 #>  #> Call: #> stats::lm(formula = y$vi_numeric$formulas$linear, data = y$vi_numeric$df) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.39369 -0.04100 -0.00053  0.04417  0.32204  #>  #> Coefficients: #>                         Estimate Std. Error t value Pr(>|t|)     #> (Intercept)            1.507e-01  2.396e-02   6.291 6.08e-10 *** #> growing_season_length  1.271e-03  4.163e-05  30.523  < 2e-16 *** #> swi_min                3.844e-03  3.916e-04   9.815  < 2e-16 *** #> rainfall_min           9.932e-06  8.123e-05   0.122   0.9027     #> solar_rad_range       -3.609e-03  6.969e-04  -5.179 3.06e-07 *** #> cloud_cover_range      5.419e-04  2.880e-04   1.882   0.0603 .   #> soil_clay             -2.776e-04  4.865e-04  -0.571   0.5685     #> topo_diversity         7.559e-04  7.380e-04   1.024   0.3062     #> soil_silt             -1.749e-03  3.864e-04  -4.527 7.21e-06 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.08315 on 601 degrees of freedom #> Multiple R-squared:  0.8464, Adjusted R-squared:  0.8443  #> F-statistic: 413.9 on 8 and 601 DF,  p-value: < 2.2e-16 m1$r.squared #> [1] 0.7417704 m2$r.squared #> [1] 0.8463813 collinear::f_auto_rules() collinear::f_auto(   df = vi_smol,   response = \"vi_categorical\",   predictors = vi_predictors_categorical,   quiet = TRUE ) #> [1] \"f_categorical_rf\" collinear::f_auto(   df = vi_smol,   response = \"vi_binomial\", #ones and zeros   predictors = vi_predictors_numeric,   quiet = TRUE ) #> [1] \"f_binomial_glm\" collinear::f_auto(   df = vi_smol,   response = \"vi_counts\", #integer counts   predictors = vi_predictors_numeric,   quiet = TRUE ) #> [1] \"f_count_glm\" collinear::f_auto(   df = vi_smol,   response = \"vi_counts\",   predictors = vi_predictors, #numeric and categorical   quiet = TRUE ) #> [1] \"f_count_rf\" collinear::f_functions() x <- collinear::preference_order(   df = vi_smol,   responses = \"vi_numeric\",   predictors = vi_predictors_numeric,   f = f_numeric_gam,   quiet = TRUE ) y <- collinear::collinear(   df = vi_smol,   response = \"vi_numeric\",   predictors = vi_predictors_numeric,   preference_order = NULL,   f = f_numeric_glm,   quiet = FALSE,   cv_iterations = 100, #number of repetitions   cv_training_fraction = 0.5 #50% rows of vi_smol ) #>  #> collinear::collinear(): setting 'max_cor' to 0.618. #>  #> collinear::collinear(): setting 'max_vif' to 5.0318. #>  #> collinear::collinear(): selected predictors:  #>  - growing_season_length #>  - cloud_cover_min #>  - temperature_seasonality #>  - cloud_cover_range #>  - evapotranspiration_mean #>  - soil_clay #>  - topo_diversity #>  - humidity_range #>  - topo_elevation #>  - topo_slope #>  - soil_silt y$vi_numeric$preference_order"},{"path":"https://blasbenito.github.io/collinear/articles/intelligent_predictor_ranking.html","id":"naive-option","dir":"Articles","previous_headings":"","what":"Naive Option","title":"Intelligent Predictor Ranking","text":"final option, hypothetical user care written , sets f = NULL preference_order(). scenario, preference_order() computes pairwise correlation pairs predictors , b, c cor_matrix(), sums correlations predictor others. Finally, ranks predictors lowest highest sum correlations. option gives preference predictors contain exclusive information, exchange, might lead robust models. output shows column score computed 1 minus sum correlations, indicated column metric. Let’s use ranking collinear() fit linear model. finally, informal comparison three preference order methods described article. Please, take mind R-squared values just coarse indicators model robustness, interpreted proof one method better .","code":"x <- collinear::preference_order(   df = vi_smol,   responses = \"vi_numeric\",   predictors = vi_predictors_numeric,   f = NULL ) #>  #> collinear::preference_order(): ranking 47 'predictors' from lower to higher multicollinearity. y <- collinear::collinear(   df = vi_smol,   responses = \"vi_numeric\",   predictors = vi_predictors_numeric,   preference_order = x,   max_cor = 0.5,   max_vif = 2.5,   quiet = TRUE )  m3 <- stats::lm(   formula = y$vi_numeric$formulas$linear,   data = y$vi_numeric$df ) |>    summary() #expert mode: focused on specific variables (swi_...) m1$r.squared #> [1] 0.7417704 #intelligent predictor ranking: optimized for prediction m2$r.squared #> [1] 0.8463813 #naive option: minimizes redundancy, not optimized for prediction m3$r.squared #> [1] 0.7494892"},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Target Encoding","text":"Target encoding maps categorical predictors statistic reference numeric variable across categories. functionality, implemented target_encoding_lab(), used two different ways: function cor_df() applies compute pairwise correlations numeric categorical predictors, . function collinear() applies optionally user requests response numeric transform categorical predictors numeric speed-multicollinearity analysis.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Target Encoding","text":"code chunk prepares session article.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"how-it-works","dir":"Articles","previous_headings":"","what":"How It Works","title":"Target Encoding","text":"explain target encoding works, let’s first create little silly dataframe:","code":"df <- data.frame(   num = 1:6,   cat = c(rep(\"a\", 3), rep(\"b\", 3)) )  df #>   num cat #> 1   1   a #> 2   2   a #> 3   3   a #> 4   4   b #> 5   5   b #> 6   6   b"},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"mean-target-encoding","dir":"Articles","previous_headings":"How It Works","what":"Mean Target Encoding","title":"Target Encoding","text":"transform cat numeric can remap average num across category cat, shown code using dplyr syntax. equivalent \"mean\" encoding method implemented target_encoding_lab().","code":"df <- df |>    dplyr::group_by(cat) |>    dplyr::mutate(cat_mean = mean(num)) |>    dplyr::ungroup()  df #> # A tibble: 6 × 3 #>     num cat   cat_mean #>   <int> <chr>    <dbl> #> 1     1 a            2 #> 2     2 a            2 #> 3     3 a            2 #> 4     4 b            5 #> 5     5 b            5 #> 6     6 b            5 df <- collinear::target_encoding_lab(   df = df,   response = \"num\",   predictors = \"cat\",   methods = \"mean\",   quiet = TRUE )  df #>   num cat cat__encoded_loo #> 1   1   a              2.5 #> 2   2   a              2.0 #> 3   3   a              1.5 #> 4   4   b              5.5 #> 5   5   b              5.0 #> 6   6   b              4.5"},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"leave-one-out-target-encoding","dir":"Articles","previous_headings":"How It Works","what":"Leave-One-Out Target Encoding","title":"Target Encoding","text":"Another encoding method leave-one-(\"loo\"), computes group mean excluding current observation. given case, sums numeric values category, subtracts current row’s value, divides count observations category minus one. code replicates behavior. Notice encoded values now vary within category. category “”: rows get values based two observations “”, happens “b”. method can applied target_encoding_lab() setting method \"loo\".","code":"df <- df |>    dplyr::group_by(cat) |>    dplyr::mutate(     cat_loo = (sum(num) - num) / (dplyr::n() - 1)     ) |>    dplyr::ungroup()  df #> # A tibble: 6 × 4 #>     num cat   cat__encoded_loo cat_loo #>   <int> <fct>            <dbl>   <dbl> #> 1     1 a                  2.5     2.5 #> 2     2 a                  2       2   #> 3     3 a                  1.5     1.5 #> 4     4 b                  5.5     5.5 #> 5     5 b                  5       5   #> 6     6 b                  4.5     4.5 df <- collinear::target_encoding_lab(   df = df,   response = \"num\",   predictors = \"cat\",   methods = \"loo\",   quiet = TRUE )  df #>   num cat cat__encoded_loo #> 1   1   a              2.5 #> 2   2   a              2.0 #> 3   3   a              1.5 #> 4   4   b              5.5 #> 5   5   b              5.0 #> 6   6   b              4.5"},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"rank-target-encoding","dir":"Articles","previous_headings":"How It Works","what":"Rank Target Encoding","title":"Target Encoding","text":"rank method orders categories mean values assigns integer ranks. useful capture ordinal relationship categories without sensitive outliers extreme values. dplyr version algorithm bit verbose, hope trick: method can applied via target_encoding_lab() encoding_method = \"rank\".","code":"df <- df |>   dplyr::group_by(cat) |>   dplyr::mutate(     cat_mean = mean(num)     ) |>   dplyr::ungroup() |>   dplyr::mutate(     cat_rank = dplyr::dense_rank(cat_mean)     )  df #> # A tibble: 6 × 4 #>     num cat   cat_mean cat_rank #>   <int> <fct>    <dbl>    <int> #> 1     1 a            2        1 #> 2     2 a            2        1 #> 3     3 a            2        1 #> 4     4 b            5        2 #> 5     5 b            5        2 #> 6     6 b            5        2 df <- collinear::target_encoding_lab(   df = df,   response = \"num\",   predictors = \"cat\",   methods = \"rank\",   quiet = TRUE )  df #>   num cat cat__encoded_loo #> 1   1   a              2.5 #> 2   2   a              2.0 #> 3   3   a              1.5 #> 4   4   b              5.5 #> 5   5   b              5.0 #> 6   6   b              4.5"},{"path":[]},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"computing-correlations-with-mixed-variable-types","dir":"Articles","previous_headings":"Target Encoding in Practice","what":"Computing Correlations with Mixed Variable Types","title":"Target Encoding","text":"computing pairwise correlations numeric categorical predictors, cor_df() automatically applies leave-one-target encoding behind scenes. applying target_encoding_lab() method \"loo\" compute pairwise correlation stats::cor().","code":"x <- collinear::cor_df(   df = collinear::vi_smol,   predictors = c(     \"soil_temperature_mean\", # numeric     \"koppen_zone\"            # categorical   ),   quiet = TRUE )  x #>                       x           y correlation  metric #> 1 soil_temperature_mean koppen_zone   0.9195774 Pearson df <- collinear::target_encoding_lab(   df = vi_smol,   response = \"soil_temperature_mean\",   predictor = \"koppen_zone\",   encoding_method = \"loo\",   overwrite = TRUE,   quiet = TRUE )  stats::cor(   x = df$soil_temperature_mean,   y = df$koppen_zone ) #> [1] 0.9195774"},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"speeding-up-multicollinearity-analysis","dir":"Articles","previous_headings":"Target Encoding in Practice","what":"Speeding Up Multicollinearity Analysis","title":"Target Encoding","text":"Enabling target encoding working numeric responses categorical predictors collinear() provides two key advantages: Speeds computation considerably, importantly. Replaces Cramer’s V associations pairs categorical variables Pearson correlations pairs numeric variables, providing statistically sound multicollinearity assessment. speed-considerable! ’s consequence applying target encoding. Let’s take look variable selections run. selection resulting run target encoding bit shorter. ? without target encoding, pairwise associations categorical predictors computed Cramer’s V, tends underestimate association high cardinality (number categories). Hence, target encoding applied, collinear() captures true multicollinearity ensures consistent filtering across predictors, matter type.","code":"# without target encoding time_without <- system.time({   result_without_encoding <- collinear::collinear(     df = vi_smol,     responses = \"vi_numeric\",     predictors = vi_predictors_categorical,     encoding_method = NULL,     quiet = TRUE   ) })  # with target encoding time_with <- system.time({   result_with_encoding <- collinear::collinear(     df = vi_smol,     responses = \"vi_numeric\",     predictors = vi_predictors_categorical,     encoding_method = \"loo\",     quiet = TRUE   ) })  data.frame(   encoding = c(\"No\", \"Yes\"),   seconds = c(time_without[\"elapsed\"], time_with[\"elapsed\"]) ) #>   encoding seconds #> 1       No  10.443 #> 2      Yes   2.510 result_without_encoding$vi_numeric$selection #> [1] \"koppen_zone\"      \"soil_type\"        \"biogeo_ecoregion\" \"country_name\"     #> attr(,\"validated\") #> [1] TRUE result_with_encoding$vi_numeric$selection #> [1] \"koppen_zone\"  \"subregion\"    \"biogeo_realm\" \"continent\"    #> attr(,\"validated\") #> [1] TRUE"},{"path":"https://blasbenito.github.io/collinear/articles/target_encoding.html","id":"important-considerations","dir":"Articles","previous_headings":"","what":"Important Considerations","title":"Target Encoding","text":"Overfitting Risk: Mean encoding can leak information response predictor. leave-one-method mitigates risk generally recommended modeling workflows. Category Frequency: Target encoding works best categories sufficient observations. Categories observations may produce unstable encoded values. Use Target Encoding: Enable encoding_method = \"loo\" collinear() numeric response categorical predictors, want accurate multicollinearity assessment. improved statistical soundness computational speed make preferred approach mixed data types.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/unified_correlation_framework.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Unified Correlation Framework","text":"function cor_df() combines several methods compute pairwise associations variables different types: Numeric vs. numeric: Pearson correlation. Numeric vs. categorical: Combines target encoding Pearson correlation. Categorical vs. categorical: Bias-corrected Cramer’s V. article provides fine-grained details functionality describes caveats combining Pearson correlation Cramer’s V cardinality categorical predictors high.","code":""},{"path":"https://blasbenito.github.io/collinear/articles/unified_correlation_framework.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Unified Correlation Framework","text":"article requires following setup Don’t miss object predictors variables contains, explanatory code herein focusing .","code":""},{"path":"https://blasbenito.github.io/collinear/articles/unified_correlation_framework.html","id":"understanding-cor_df","dir":"Articles","previous_headings":"","what":"Understanding cor_df()","title":"Unified Correlation Framework","text":"section explains detail cor_df() handles computation associations different variable types. apply cor_df() dataframe vector predictors, returns dataframe Pearson Cramer’s V association unique pairs predictors. Let’s examine function handles different predictor types.","code":"x <- collinear::cor_df(   df = vi_smol,   predictors = predictors,   quiet = TRUE )  x #>                  x             y correlation     metric #> 1 temperature_mean   koppen_zone   0.9283292    Pearson #> 2    rainfall_mean   koppen_zone   0.8443112    Pearson #> 3    rainfall_mean     soil_type   0.6741559    Pearson #> 4 temperature_mean     soil_type   0.6406734    Pearson #> 5      koppen_zone     soil_type   0.3146128 Cramer's V #> 6 temperature_mean rainfall_mean   0.2126887    Pearson"},{"path":"https://blasbenito.github.io/collinear/articles/unified_correlation_framework.html","id":"numeric-vs--numeric","dir":"Articles","previous_headings":"Understanding cor_df()","what":"Numeric vs. Numeric","title":"Unified Correlation Framework","text":"simplest reliable case cor_df() handles, pairwise Pearson correlations computed fast stats::cor(). parallelization setup ignored case.","code":"predictors_numeric <- collinear::identify_numeric_variables(   df = vi_smol,   predictors = predictors )$valid  stats::cor(   x = vi_smol[, predictors_numeric],   use = \"complete.obs\",   method = \"pearson\" ) |>    abs() #>                  temperature_mean rainfall_mean #> temperature_mean        1.0000000     0.2126887 #> rainfall_mean           0.2126887     1.0000000"},{"path":"https://blasbenito.github.io/collinear/articles/unified_correlation_framework.html","id":"numeric-vs--categorical","dir":"Articles","previous_headings":"Understanding cor_df()","what":"Numeric vs. Categorical","title":"Unified Correlation Framework","text":"handle situation, cor_df() first applies target encoding categorical predictor using numeric variable reference, applies stats::cor() compute Pearson correlation.","code":"#transform koppen_zone to numeric df <- target_encoding_lab(   df = vi_smol,   response = \"temperature_mean\",   predictors = \"koppen_zone\",   encoding_method = \"loo\",   overwrite = TRUE,   quiet = TRUE )  stats::cor(   x = df[[\"temperature_mean\"]],   y = df[[\"koppen_zone\"]],   use = \"complete.obs\",   method = \"pearson\" ) |>   abs() #> [1] 0.9283292"},{"path":"https://blasbenito.github.io/collinear/articles/unified_correlation_framework.html","id":"categorical-vs--categorical","dir":"Articles","previous_headings":"Understanding cor_df()","what":"Categorical vs. Categorical","title":"Unified Correlation Framework","text":"case solved via bias-corrected Cramer’s V, based Pearson’s chi-squared statistic. method implemented function cor_cramer().","code":"collinear::cor_cramer(   x = vi_smol[[\"koppen_zone\"]],   y = vi_smol[[\"soil_type\"]] ) #> [1] 0.3146128"},{"path":"https://blasbenito.github.io/collinear/articles/unified_correlation_framework.html","id":"comparing-cramers-v-and-pearson-correlation","dir":"Articles","previous_headings":"Understanding cor_df()","what":"Comparing Cramer’s V and Pearson Correlation","title":"Unified Correlation Framework","text":"Now know cor_df() handles different cases, important question answer: Cramer’s V Pearson correlation comparable? Let’s try answer question empirically small simulation. generates integer vectors different cardinality levels compares using stats::cor() cor_cramer(). scatterplot shows simulation results across cardinality levels, linear smooths group.  Notice relationship Cramer’s V Pearson correlation tight binary variables, deteriorates rapidly cardinality increases. Moreover, Cramer’s V tends produce smaller values Pearson’s correlation. creates systematic bias favoring categorical predictors multicollinearity analysis two measures compared directly. make users aware issue, function returns either message warning. message appears least two categorical one numeric predictor quiet = FALSE. warning appears quiet = TRUE.","code":"set.seed(1)  #simulation parameters sim <- data.frame(   classes = rep(x = c(2, 4, 8, 16), times = 1000),   cor = NA_real_,   cramer_v = NA_real_ )  #run simulation for(i in seq_len(nrow(sim))) {      #generate integer vector with n classes   x <- sample(x = 1:sim$classes[i], size = 30, replace = TRUE)      #reshuffle x to get y with same marginal distribution   y <- sample(x)      #compute absolute Pearson correlation   sim$cor[i] <- abs(stats::cor(x, y))      #compute Cramer's V   sim$cramer_v[i] <- collinear::cor_cramer(x, y)    } x <- collinear::cor_df(   df = vi_smol,   predictors = predictors,   quiet = FALSE ) #>  #> collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. x <- collinear::cor_df(   df = vi_smol,   predictors = predictors,   quiet = TRUE ) #> Warning:  #> collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue."},{"path":"https://blasbenito.github.io/collinear/articles/unified_correlation_framework.html","id":"recommendations","dir":"Articles","previous_headings":"","what":"Recommendations","title":"Unified Correlation Framework","text":"Based analysis , practical recommendations: numeric predictors : Use cor_df() without concerns, represents best-case scenario. mixed predictors low-cardinality categoricals: cor_df() works well -, though aware slight underestimation Cramer’s V values. high-cardinality categoricals: Consider using target_encoding_lab() convert numeric analysis. Alternatively, use collinear() encoding_method = \"loo\", handles automatically. provides reliable multicollinearity assessment.","code":""},{"path":"https://blasbenito.github.io/collinear/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Blas M. Benito. Author, maintainer, copyright holder.","code":""},{"path":"https://blasbenito.github.io/collinear/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Benito B (2023). “collinear: R Package Seamless Multicollinearity Management.” doi:10.5281/zenodo.10039489, https://blasbenito.github.io/collinear/.","code":"@Misc{,   title = {{collinear}: R Package for Seamless Multicollinearity Management},   author = {Blas M. Benito},   year = {2023},   url = {https://blasbenito.github.io/collinear/},   doi = {10.5281/zenodo.10039489}, }"},{"path":[]},{"path":"https://blasbenito.github.io/collinear/index.html","id":"summary","dir":"","previous_headings":"","what":"Summary","title":"collinear: Automated Multicollinearity Management","text":"R package collinear provides comprehensive toolkit smart multicollinearity management datasets mixed variable types. main function, collinear(), integrates five core components: Target Encoding (function target_encoding_lab()): Transparently converts categorical predictors numeric required, enabling VIF correlation analysis across mixed data types. Intelligent Predictor Ranking (function preference_order()): Prioritizes predictors univariate association response ensure relevant ones retained filtering. Unified Correlation Framework (function cor_df()): Computes pairwise correlations variable types using Pearson correlation (numeric-numeric), target encoding (numeric-categorical), Cramer’s V (categorical-categorical) within single, consistent workflow. Adaptive Filtering Thresholds (function collinear()): Automatically configures correlation VIF thresholds based dataset’s correlation structure, eliminating guesswork allowing manual override. Dual Filtering Strategy (function collinear_select()): Combines pairwise correlation Variance Inflation Factor filtering considering predictor rankings manage multicollinearity maximizing predictive power resulting selection predictors. methods, except target encoding also fully integrated tidymodels implementation step_collinear(). package also provides diagnostic functions (cor_df(), vif_df(), collinear_stats()) help users assess multicollinearity data filtering.","code":""},{"path":"https://blasbenito.github.io/collinear/index.html","id":"install","dir":"","previous_headings":"","what":"Install","title":"collinear: Automated Multicollinearity Management","text":"package collinear can installed CRAN. development version can installed GitHub. Previous versions archive_xxx branches GitHub repository.","code":"install.packages(\"collinear\") remotes::install_github(   repo = \"blasbenito/collinear\",    ref = \"development\"   ) remotes::install_github(   repo = \"blasbenito/collinear\",    ref = \"archive_v2.0.0\"   )"},{"path":[]},{"path":"https://blasbenito.github.io/collinear/index.html","id":"setup","dir":"","previous_headings":"Getting Started","what":"Setup","title":"collinear: Automated Multicollinearity Management","text":"functions collinear package support parallelization progress bars via future progressr. Parallelization, however, advantageous large datasets including categorical predictors.","code":"library(collinear) library(future) library(progressr)  future::plan(   future::multisession,   workers = future::availableCores() - 1   )  #does not work in Rmarkdown #progressr::handlers(global = TRUE)"},{"path":"https://blasbenito.github.io/collinear/index.html","id":"example-data","dir":"","previous_headings":"Getting Started","what":"Example Data","title":"collinear: Automated Multicollinearity Management","text":"example dataframe vi_smol several response variables large set predictors. focus numeric response vi_numeric, complete set numeric categorical predictors, stored vector vi_predictors.","code":"data(vi_smol, vi_predictors) nrow(vi_smol) #> [1] 610 length(vi_predictors) #> [1] 58"},{"path":"https://blasbenito.github.io/collinear/index.html","id":"multicollinearity-analysis","dir":"","previous_headings":"Getting Started","what":"Multicollinearity Analysis","title":"collinear: Automated Multicollinearity Management","text":"package provides several functions assess multicollinearity. functions cor_df() vif_df() generate dataframes pairwise correlations VIF scores predictors, functions cor_stats(), vif_stats() (used ) collinear_stats() generate descriptive multicollinearity statistics. Notice function takes execute computing correlations categorical variables vi_predictors computationally expensive. quantile 0.75 returned vif_stats() indicates 25% predictors VIF score higher 6.5. suggests substantial redundancy set predictors.","code":"collinear::vif_stats(   df = vi_smol,   predictors = vi_predictors,   quiet = TRUE ) #> Warning:  #> collinear::vif_stats() #> └── collinear::vif_df() #>     └── collinear::cor_matrix() #>         └── collinear::cor_df(): 11 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. #>   method     statistic     value #> 1    vif             n   58.0000 #> 2    vif       minimum -194.5080 #> 3    vif quantile_0.05  -11.2993 #> 4    vif quantile_0.25    0.4528 #> 5    vif          mean   67.8998 #> 6    vif        median   25.2999 #> 7    vif quantile_0.75   90.3970 #> 8    vif quantile_0.95  316.6229 #> 9    vif       maximum  629.6362"},{"path":"https://blasbenito.github.io/collinear/index.html","id":"multicollinearity-filtering","dir":"","previous_headings":"Getting Started","what":"Multicollinearity Filtering","title":"collinear: Automated Multicollinearity Management","text":"reduce multicollinearity vi_smol apply collinear() minimal setup. function returns object class collinear_output, print() summary() methods. object df contains response selected predictors. object preference_order contains ranking predictors. computed function preference_order() assessing association response predictors. case, fits univariate models response predictor using f_numeric_rf, returns R-squared observations vs model predictions. ranking ensures important predictors protected multicollinearity filtering. object selection contains non-collinear predictors chosen taking account pairwise correlation VIF predictors, position ranking . can check selection predictors shows low multicollinearity running function vif_df() . VIF scores 2.5, collinear() good job ! Finally, collinear() also returns modeling formulas help kick start exploratory modelling. function returns linear formulas numeric outcomes, classification formulas categorical outcomes.","code":"x <- collinear::collinear(   df = vi_smol,   response = \"vi_numeric\",   predictors = vi_predictors ) #>  #> collinear::collinear() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  - koppen_group #>  - koppen_description #>  - biogeo_ecoregion #>  - biogeo_biome #>  - biogeo_realm #>  - country_name #>  - continent #>  - region #>  - subregion #>  #> collinear::collinear() #> └── collinear::cor_df(): 11 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. #>  #> collinear::collinear(): setting 'max_cor' to 0.6842. #>  #> collinear::collinear(): setting 'max_vif' to 6.5269. #>  #> collinear::collinear() #> └── collinear::preference_order() #>     └── collinear::f_auto(): selected function 'f_numeric_rf()' to compute preference order. #>  #> collinear::collinear() #> └── collinear::collinear_select() #>     └── collinear::vif(): some VIF values exceeded 1M and were set to Inf. #>  #> collinear::collinear(): selected predictors:  #>  - rainfall_mean #>  - swi_mean #>  - evapotranspiration_max #>  - evapotranspiration_range #>  - swi_min #>  - soil_soc #>  - humidity_range #>  - topo_elevation #>  - cloud_cover_range #>  - continent #>  - soil_sand #>  - topo_diversity #>  - topo_slope x #> Result #> =================== #>  - response: vi_numeric #>    -------------------- #>  #>  + df: #>    - rows: 610 #>    - cols: 14 #>  #>  + preference order: #>    + df: #>      - rows: 58 #>      - cols: 6 #>    + preference: #>      - rainfall_mean #>      - growing_season_rainfall #>      - growing_season_length #>      - swi_mean #>      - aridity_index #>    + f: f_numeric_rf #>  #>  + selection: #>    - rainfall_mean #>    - swi_mean #>    - evapotranspiration_max #>    - evapotranspiration_range #>    - swi_min #>    - ... (8 ommited) #>  #>  + formulas: #>    - linear: vi_numeric ~ rainfall_mean + swi_mean + evapotranspiration_max + evapotranspiration_range + swi_min + ... (8 terms omitted)  #>    - smooth: vi_numeric ~ s(rainfall_mean) + s(swi_mean) + s(evapotranspiration_max) + s(evapotranspiration_range) + s(swi_min) + ... (8 terms omitted) colnames(x$vi_numeric$df) #>  [1] \"vi_numeric\"               \"rainfall_mean\"            #>  [3] \"swi_mean\"                 \"evapotranspiration_max\"   #>  [5] \"evapotranspiration_range\" \"swi_min\"                  #>  [7] \"soil_soc\"                 \"humidity_range\"           #>  [9] \"topo_elevation\"           \"cloud_cover_range\"        #> [11] \"continent\"                \"soil_sand\"                #> [13] \"topo_diversity\"           \"topo_slope\" head(x$vi_numeric$preference_order) #>     response               predictor            f    metric  score rank #> 1 vi_numeric           rainfall_mean f_numeric_rf R-squared 0.8835    1 #> 2 vi_numeric growing_season_rainfall f_numeric_rf R-squared 0.8731    2 #> 3 vi_numeric   growing_season_length f_numeric_rf R-squared 0.8644    3 #> 4 vi_numeric                swi_mean f_numeric_rf R-squared 0.8333    4 #> 5 vi_numeric           aridity_index f_numeric_rf R-squared 0.8279    5 #> 6 vi_numeric             koppen_zone f_numeric_rf R-squared 0.8174    6 x$vi_numeric$selection #>  [1] \"rainfall_mean\"            \"swi_mean\"                 #>  [3] \"evapotranspiration_max\"   \"evapotranspiration_range\" #>  [5] \"swi_min\"                  \"soil_soc\"                 #>  [7] \"humidity_range\"           \"topo_elevation\"           #>  [9] \"cloud_cover_range\"        \"continent\"                #> [11] \"soil_sand\"                \"topo_diversity\"           #> [13] \"topo_slope\"               #> attr(,\"validated\") #> [1] TRUE collinear::vif_df(   df = x$vi_numeric$df,   predictors = x$vi_numeric$selection ) #>        vif                predictor #> 1   4.7203        cloud_cover_range #> 2   3.3447                continent #> 3   3.1112   evapotranspiration_max #> 4   3.0627 evapotranspiration_range #> 5   2.3856           humidity_range #> 6   2.0747            rainfall_mean #> 7   1.9928                soil_sand #> 8   1.7690                 soil_soc #> 9   1.6346                 swi_mean #> 10  1.5984                  swi_min #> 11  1.3531           topo_diversity #> 12  0.9320           topo_elevation #> 13 -0.2235               topo_slope x$vi_numeric$formulas #> $linear #> vi_numeric ~ rainfall_mean + swi_mean + evapotranspiration_max +  #>     evapotranspiration_range + swi_min + soil_soc + humidity_range +  #>     topo_elevation + cloud_cover_range + continent + soil_sand +  #>     topo_diversity + topo_slope #> <environment: 0x5adb1977e4b0> #>  #> $smooth #> vi_numeric ~ s(rainfall_mean) + s(swi_mean) + s(evapotranspiration_max) +  #>     s(evapotranspiration_range) + s(swi_min) + s(soil_soc) +  #>     s(humidity_range) + s(topo_elevation) + s(cloud_cover_range) +  #>     continent + s(soil_sand) + s(topo_diversity) + s(topo_slope) #> <environment: 0x5adb1977e4b0>"},{"path":"https://blasbenito.github.io/collinear/index.html","id":"model-fitting","dir":"","previous_headings":"Getting Started","what":"Model Fitting","title":"collinear: Automated Multicollinearity Management","text":"output collinear() can used right away fit exploratory models, shown .","code":"m <- lm(   formula = x$vi_numeric$formulas$linear,    data = x$vi_numeric$df,   na.action = na.omit   )  summary(m) #>  #> Call: #> lm(formula = x$vi_numeric$formulas$linear, data = x$vi_numeric$df,  #>     na.action = na.omit) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.42639 -0.04274  0.00107  0.04804  0.24228  #>  #> Coefficients: #>                            Estimate Std. Error t value Pr(>|t|)     #> (Intercept)               3.027e-01  4.557e-02   6.644 6.97e-11 *** #> rainfall_mean             4.183e-05  7.152e-06   5.849 8.22e-09 *** #> swi_mean                  6.997e-03  4.415e-04  15.850  < 2e-16 *** #> evapotranspiration_max   -1.206e-03  1.694e-04  -7.117 3.22e-12 *** #> evapotranspiration_range -1.763e-04  1.396e-04  -1.263 0.207122     #> swi_min                  -2.473e-03  6.162e-04  -4.013 6.77e-05 *** #> soil_soc                 -4.845e-04  1.944e-04  -2.492 0.012964 *   #> humidity_range           -1.042e-03  6.301e-04  -1.654 0.098731 .   #> topo_elevation           -3.991e-05  7.280e-06  -5.481 6.27e-08 *** #> cloud_cover_range         5.109e-04  3.588e-04   1.424 0.155005     #> continentAsia            -2.847e-02  1.227e-02  -2.320 0.020687 *   #> continentEurope           3.893e-02  1.895e-02   2.054 0.040412 *   #> continentNorth America    6.304e-02  1.525e-02   4.134 4.08e-05 *** #> continentOceania          4.555e-02  1.478e-02   3.083 0.002146 **  #> continentSouth America    5.547e-02  1.242e-02   4.466 9.54e-06 *** #> soil_sand                 5.123e-04  2.821e-04   1.816 0.069887 .   #> topo_diversity            3.318e-03  8.973e-04   3.698 0.000238 *** #> topo_slope                4.209e-03  1.392e-03   3.024 0.002600 **  #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.08237 on 589 degrees of freedom #>   (3 observations deleted due to missingness) #> Multiple R-squared:  0.8515, Adjusted R-squared:  0.8473  #> F-statistic: 198.7 on 17 and 589 DF,  p-value: < 2.2e-16"},{"path":"https://blasbenito.github.io/collinear/index.html","id":"integration-with-tidymodels","dir":"","previous_headings":"Getting Started","what":"Integration with tidymodels","title":"collinear: Automated Multicollinearity Management","text":"function step_collinear() wraps collinear() facilitate usage tidymodels recipes. Please notice step_collinear() perform target encoding, combining functionality multicollinearity filtering fit well recipes works.","code":"library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(recipes) #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step library(parsnip) library(workflows)  # model formula vi_formula <- collinear::model_formula(   df = vi_smol,   response = \"vi_numeric\",   predictors = vi_predictors )  # recipe vi_recipe <- recipes::recipe(   formula = vi_formula,   data = vi_smol   ) |>   #multicollinearity filtering   collinear::step_collinear(     recipes::all_predictors()   )  #linear model vi_model <- parsnip::rand_forest() |>   parsnip::set_engine(\"ranger\", importance = \"permutation\") |>   parsnip::set_mode(\"regression\")  #create and fit workflow vi_model <- parsnip::linear_reg() |>   parsnip::set_engine(\"lm\")  # create and fit workflow vi_workflow <- workflows::workflow() |>   workflows::add_recipe(vi_recipe) |>   workflows::add_model(vi_model) |>   workflows::fit(data = vi_smol) #> Warning:  #> collinear::collinear() #> └── collinear::cor_df(): 11 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  vi_workflow #> ══ Workflow [trained] ══════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: linear_reg() #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 1 Recipe Step #>  #> • step_collinear() #>  #> ── Model ─────────────────────────────────────────────────────────────────────── #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>              (Intercept)             rainfall_mean                  swi_mean   #>                3.027e-01                 4.183e-05                 6.997e-03   #>   evapotranspiration_max  evapotranspiration_range                   swi_min   #>               -1.206e-03                -1.763e-04                -2.473e-03   #>                 soil_soc            humidity_range            topo_elevation   #>               -4.845e-04                -1.042e-03                -3.991e-05   #>        cloud_cover_range             continentAsia           continentEurope   #>                5.109e-04                -2.847e-02                 3.893e-02   #>   continentNorth America          continentOceania    continentSouth America   #>                6.304e-02                 4.555e-02                 5.547e-02   #>                soil_sand            topo_diversity                topo_slope   #>                5.123e-04                 3.318e-03                 4.209e-03"},{"path":"https://blasbenito.github.io/collinear/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"collinear: Automated Multicollinearity Management","text":"find package useful, please cite : Blas M. Benito (2025). collinear: R Package Automated Multicollinearity Management. Version 3.0.0. doi: 10.5281/zenodo.17843578","code":""},{"path":"https://blasbenito.github.io/collinear/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"collinear: Automated Multicollinearity Management","text":"encounter bugs issues documentation, please file issue GitHub.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/case_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate sample weights for imbalanced responses — case_weights","title":"Generate sample weights for imbalanced responses — case_weights","text":"Computes case weights adding one response variables types: numeric binomial (1 0). logical (TRUE FALSE): converted numeric internally. categorical (character factor) Values NA, Inf, -Inf, NaN invalid numeric logical variables result errors. categorical variables, converted respective categories (\"NA\", \"Inf\", \"-Inf\", \"NaN\") assigned case weights. returned weights sum one.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/case_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate sample weights for imbalanced responses — case_weights","text":"","code":"case_weights(x = NULL, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/case_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate sample weights for imbalanced responses — case_weights","text":"x (required, integer, character, factor vector) Values binomial, categorical, factor variable. Default: NULL ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/case_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate sample weights for imbalanced responses — case_weights","text":"numeric vector: case weights","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/case_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate sample weights for imbalanced responses — case_weights","text":"","code":"#numeric vector  y <- case_weights(    x = c(0, 0, 1, 1)    )   #logical vector  y <- case_weights(    x = c(TRUE, TRUE, FALSE, FALSE)    )   #character vector  y <- case_weights(    x = c(\"a\", \"a\", \"b\", \"c\")    )"},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":null,"dir":"Reference","previous_headings":"","what":"Smart multicollinearity management — collinear","title":"Smart multicollinearity management — collinear","text":"Automates multicollinearity management datasets mixed variable types (numeric, categorical, logical) integrated system five key components: Target Encoding Integration (opt-) responses numeric, categorical predictors can converted numeric using response values reference. enables VIF correlation analysis across mixed types. See target_encoding_lab. Intelligent Predictor Ranking (active default) Three prioritization strategies ensure relevant predictors retained filtering: User-defined ranking (argument preference_order): Accepts character vector predictor names dataframe preference_order. Lower-ranked collinear predictors removed. Response-based ranking (f): Uses f_auto, f_numeric_glm, f_binomial_rf rank predictors association response. Supports cross-validation via preference_order. Multicollinearity-based ranking (default): preference_order f NULL, predictors ranked lower higher multicollinearity. Unified Correlation Framework (active default) Computes pairwise correlations variable types using Pearson (numeric–numeric), target encoding (numeric–categorical), Cramer's V (categorical–categorical). See cor_df, cor_matrix, cor_cramer. Adaptive Filtering Thresholds (active default) max_cor max_vif NULL, thresholds determined median correlation structure predictors. Dual Filtering Strategy (active default) Combines two complementary methods respecting predictor rankings: Pairwise Correlation Filtering: Removes predictors Pearson correlation Cramer's V max_cor. See cor_select. VIF-based Filtering: Removes numeric predictors VIF max_vif. See vif_select, vif_df, vif. function accepts parallelization via future::plan() progress bars via progressr::handlers(). Parallelization benefits target_encoding_lab, preference_order, cor_select.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smart multicollinearity management — collinear","text":"","code":"collinear(   df = NULL,   responses = NULL,   predictors = NULL,   encoding_method = NULL,   preference_order = NULL,   f = f_auto,   max_cor = NULL,   max_vif = NULL,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smart multicollinearity management — collinear","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. encoding_method (optional; character NULL) One \"loo\", \"mean\", \"rank\". NULL, target encoding disabled. Default: NULL. preference_order (optional; character vector, dataframe preference_order, NULL) Prioritizes predictors preserve. f (optional; unquoted function name NULL) Function rank predictors relationship responses. See f_functions. Default: f_auto. max_cor (optional; numeric NULL) Maximum allowed pairwise correlation (0.01–0.99). Recommended 0.5 0.9. NULL max_vif NULL, selected automatically. Default: NULL. max_vif (optional; numeric NULL) Maximum allowed VIF. Recommended 2.5 10. NULL max_cor NULL, configured automatically. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smart multicollinearity management — collinear","text":"list class collinear_output sublists class collinear_selection. responses = NULL single sublist named \"result\" returned; otherwise sublist per response returned.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"adaptive-multicollinearity-thresholds","dir":"Reference","previous_headings":"","what":"Adaptive Multicollinearity Thresholds","title":"Smart multicollinearity management — collinear","text":"max_cor max_vif NULL, function determines thresholds follows: Compute 75th percentile pairwise correlations via cor_stats. Map value sigmoid 0.545 (VIF~2.5) 0.785 (VIF~7.5), centered 0.665, get max_cor. Compute max_vif max_cor using gam_cor_to_vif.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"variance-inflation-factors","dir":"Reference","previous_headings":"","what":"Variance Inflation Factors","title":"Smart multicollinearity management — collinear","text":"VIF predictor \\(\\) computed \\(1/(1-R^2)\\), \\(R^2\\) multiple R-squared regressing \\(\\) predictors. Recommended maximums commonly used 2.5, 5, 10.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"vif-based-filtering","dir":"Reference","previous_headings":"","what":"VIF-based Filtering","title":"Smart multicollinearity management — collinear","text":"vif_select ranks numeric predictors (user preference_order provided, otherwise lower higher VIF) sequentially adds predictors whose VIF current selection max_vif.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"pairwise-correlation-filtering","dir":"Reference","previous_headings":"","what":"Pairwise Correlation Filtering","title":"Smart multicollinearity management — collinear","text":"cor_select computes global correlation matrix, orders predictors preference_order lower--higher summed correlations, sequentially selects predictors pairwise correlations max_cor.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Smart multicollinearity management — collinear","text":"David . Belsley, D.., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data Sources Collinearity. John Wiley & Sons. DOI: 10.1002/0471725153. Micci-Barreca, D. (2001) Preprocessing Scheme High-Cardinality Categorical Attributes Classification Prediction Problems. SIGKDD Explor. Newsl. 3, 1, 27-32. DOI: 10.1145/507533.507538","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/collinear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smart multicollinearity management — collinear","text":"","code":"data(vi_smol, vi_predictors_numeric) x <- collinear(df = vi_smol[, vi_predictors_numeric]) #>  #> collinear::collinear(): setting 'max_cor' to 0.618. #>  #> collinear::collinear(): setting 'max_vif' to 5.0318. #>  #> collinear::collinear() #> └── collinear::validate_arg_preference_order() #>     └── collinear::preference_order(): ranking 47 'predictors' from lower to higher multicollinearity. #>  #> collinear::collinear(): selected predictors:  #>  - topo_elevation #>  - topo_slope #>  - humidity_range #>  - topo_diversity #>  - soil_clay #>  - cloud_cover_range #>  - soil_silt #>  - rainfall_min #>  - growing_season_temperature #>  - swi_max #>  - soil_nitrogen #>  - temperature_seasonality #>  - rainfall_max"},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":null,"dir":"Reference","previous_headings":"","what":"Dual multicollinearity filtering algorithm — collinear_select","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"Automatizes multicollinearity filtering via pairwise correlation /variance inflation factors dataframes numeric categorical predictors. argument max_cor determines maximum pairwise correlation allowed resulting selection predictors, max_vif variance inflation factors. argument preference_order accepts character vector predictor names ranked first last index, dataframe resulting preference_order(). two predictors vector dataframe highly collinear, one lower ranking removed. option helps protect predictors interest. provided, predictors ranked lower higher multicollinearity. Please check sections Variance Inflation Factors, VIF-based Filtering, Pairwise Correlation Filtering end help file details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"","code":"collinear_select(   df = NULL,   response = NULL,   predictors = NULL,   preference_order = NULL,   max_cor = 0.61,   max_vif = 5,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional; character NULL) Name one response variable df. Used exclude columns predictors NULL, filter preference_order dataframe contains several responses. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. preference_order (optional; character vector, dataframe preference_order, NULL) Prioritizes predictors preserve. max_cor (optional; numeric NULL) Maximum correlation allowed pairs predictors. Valid values 0.01 0.99, recommended values 0.5 (strict) 0.9 (permissive). Default: 0.7 max_vif (optional, numeric NULL) Maximum Variance Inflation Factor allowed predictors multicollinearity filtering. Recommended values 2.5 (strict) 10 (permissive). Default: 5 quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"character vector: names selected predictors","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":"pairwise-correlation-filtering","dir":"Reference","previous_headings":"","what":"Pairwise Correlation Filtering","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"cor_select computes global correlation matrix, orders predictors preference_order lower--higher summed correlations, sequentially selects predictors pairwise correlations max_cor.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":"variance-inflation-factors","dir":"Reference","previous_headings":"","what":"Variance Inflation Factors","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"VIF predictor \\(\\) computed \\(1/(1-R^2)\\), \\(R^2\\) multiple R-squared regressing \\(\\) predictors. Recommended maximums commonly used 2.5, 5, 10.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":"vif-based-filtering","dir":"Reference","previous_headings":"","what":"VIF-based Filtering","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"vif_select ranks numeric predictors (user preference_order provided, otherwise lower higher VIF) sequentially adds predictors whose VIF current selection max_vif.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear_select.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dual multicollinearity filtering algorithm — collinear_select","text":"","code":"data(vi_smol)  ## OPTIONAL: parallelization setup ## irrelevant when all predictors are numeric ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  x <- collinear_select(   df = vi_smol,   predictors = c(   \"koppen_zone\",           #character   \"soil_type\",             #factor   \"topo_elevation\",        #numeric   \"soil_temperature_mean\"  #numeric     ),   max_cor = 0.7,   max_vif = 5 ) #>  #> collinear::collinear_select() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::collinear_select() #> └── collinear::cor_matrix() #>     └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. #>  #> collinear::collinear_select() #> └── collinear::validate_arg_preference_order() #>     └── collinear::preference_order(): ranking 4 'predictors' from lower to higher multicollinearity. #>  #> collinear::collinear_select() #> └── collinear::validate_arg_preference_order() #>     └── collinear::preference_order() #>         └── collinear::cor_matrix() #>             └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  x #> [1] \"topo_elevation\" \"soil_type\"      \"koppen_zone\"    #> attr(,\"validated\") #> [1] TRUE  ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/collinear_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute summary statistics for correlation and VIF — collinear_stats","title":"Compute summary statistics for correlation and VIF — collinear_stats","text":"Computes minimum, mean, maximum, quantiles 0.05, 0.25, median (0.5), 0.75, 0.95 correlations variance inflation factors given dataframe. Wraps functions cor_stats() vif_stats()","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute summary statistics for correlation and VIF — collinear_stats","text":"","code":"collinear_stats(df = NULL, predictors = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/collinear_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute summary statistics for correlation and VIF — collinear_stats","text":"df (required; dataframe, tibble, sf) dataframe predictors output cor_df(). Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/collinear_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute summary statistics for correlation and VIF — collinear_stats","text":"dataframe columns method (values \"correlation\" \"vif\"), statistic value","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/collinear_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute summary statistics for correlation and VIF — collinear_stats","text":"","code":"data(   vi_smol,   vi_predictors_numeric   )  ## OPTIONAL: parallelization setup ## irrelevant when all predictors are numeric ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  x <- collinear_stats(   df = vi_smol,   predictors = vi_predictors_numeric )  x #>         method     statistic     value #> 1  correlation             n 1081.0000 #> 2  correlation       minimum    0.0011 #> 3  correlation quantile_0.05    0.0426 #> 4  correlation quantile_0.25    0.1817 #> 5  correlation          mean    0.3980 #> 6  correlation        median    0.3610 #> 7  correlation quantile_0.75    0.6184 #> 8  correlation quantile_0.95    0.8264 #> 9  correlation       maximum    0.9893 #> 10         vif             n   47.0000 #> 11         vif       minimum    1.8158 #> 12         vif quantile_0.05    3.7499 #> 13         vif quantile_0.25   58.1814 #> 14         vif          mean  214.5167 #> 15         vif        median  170.1444 #> 16         vif quantile_0.75  354.2920 #> 17         vif quantile_0.95  520.9411 #> 18         vif       maximum  553.2944  ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Group predictors by hierarchical correlation clustering — cor_clusters","title":"Group predictors by hierarchical correlation clustering — cor_clusters","text":"Hierarchical clustering predictors correlation matrix. Computes correlation matrix cor_df() cor_matrix(), transforms distance matrix using stats::dist(), computes clustering solution stats::hclust(), applies stats::cutree() separate groups based value argument max_cor. Returns dataframe predictor names clusters, optionally, prints dendrogram clustering solution. Accepts parallelization setup via future::plan() progress bar via progressr::handlers() (see examples).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group predictors by hierarchical correlation clustering — cor_clusters","text":"","code":"cor_clusters(   df = NULL,   predictors = NULL,   max_cor = 0.7,   method = \"complete\",   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/cor_clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group predictors by hierarchical correlation clustering — cor_clusters","text":"df (required; dataframe, tibble, sf) dataframe predictors output cor_df(). Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. max_cor (optional; numeric NULL) Correlation value used separate clustering groups. Valid values 0.01 0.99. Default: 0.7 method (optional, character string) Argument stats::hclust() defining agglomerative method. One : \"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\" (= UPGMA), \"mcquitty\" (= WPGMA), \"median\" (= WPGMC) \"centroid\" (= UPGMC). Unambiguous abbreviations accepted well. Default: \"complete\". quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group predictors by hierarchical correlation clustering — cor_clusters","text":"list: df: dataframe predictor names cluster IDs. hclust: clustering object","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/cor_clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group predictors by hierarchical correlation clustering — cor_clusters","text":"","code":"data(vi_smol)  ## OPTIONAL: parallelization setup ## irrelevant when all predictors are numeric ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  #group predictors using max_cor as clustering threshold clusters <- cor_clusters(   df = vi_smol,   predictors = c(     \"koppen_zone\", #character     \"soil_type\", #factor     \"topo_elevation\", #numeric     \"soil_temperature_mean\" #numeric   ),   max_cor = 0.75 ) #>  #> collinear::cor_clusters() #> └── collinear::cor_matrix() #>     └── collinear::cor_df() #>         └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::cor_clusters() #> └── collinear::cor_matrix() #>     └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  #clusters dataframe clusters$df #>               predictor cluster #> 1           koppen_zone       1 #> 2 soil_temperature_mean       1 #> 3             soil_type       2 #> 4        topo_elevation       3  ##plot hclust object # graphics::plot(clusters$hclust)  ##plot max_cor threshold # graphics::abline( #   h = 1 - 0.75, #   col = \"red4\", #   lty = 3, #   lwd = 2 # )  ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_cramer.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify association between categorical variables — cor_cramer","title":"Quantify association between categorical variables — cor_cramer","text":"Cramer's V extends chi-squared test quantify strongly categories two variables co-occur. value ranges 0 1, 0 indicates  association 1 indicates perfect association. function implements bias-corrected version Cramer's V, adjusts sample size accurate small samples. However, bias correction means even binary variables, Cramer's V equal Pearson correlation (standard, uncorrected Cramer's V match Pearson binary data). number categories increases, Cramer's V Pearson correlation measure increasingly different aspects association directly compared. intend combine measures multicollinearity analysis, interpret care. often preferable convert non-numeric variables numeric form (example, via target encoding) assessing multicollinearity.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_cramer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify association between categorical variables — cor_cramer","text":"","code":"cor_cramer(x = NULL, y = NULL, check_input = TRUE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_cramer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify association between categorical variables — cor_cramer","text":"x (required; vector) Values categorical variable (character vector). Converted character numeric logical. Default: NULL y (required; vector) Values categorical variable (character vector). Converted character numeric logical. Default: NULL check_input (required; logical) FALSE, disables data checking slightly faster execution. Default: TRUE ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_cramer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify association between categorical variables — cor_cramer","text":"numeric: Cramer's V","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_cramer.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quantify association between categorical variables — cor_cramer","text":"Cramér, H. (1946). Mathematical Methods Statistics. Princeton: Princeton University Press, page 282 (Chapter 21. two-dimensional case). ISBN 0-691-08004-6","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/cor_cramer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quantify association between categorical variables — cor_cramer","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_cramer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify association between categorical variables — cor_cramer","text":"","code":"# perfect one-to-one association cor_cramer(   x = c(\"a\", \"a\", \"b\", \"c\"),   y = c(\"a\", \"a\", \"b\", \"c\") ) #> [1] 1  # still perfect: labels differ but mapping is unique cor_cramer(   x = c(\"a\", \"a\", \"b\", \"c\"),   y = c(\"a\", \"a\", \"b\", \"d\") ) #> [1] 1  # high but < 1: mostly aligned, one category of y repeats cor_cramer(   x = c(\"a\", \"a\", \"b\", \"c\"),   y = c(\"a\", \"a\", \"b\", \"b\") ) #> [1] 0.7071068  # appears similar by position, but no association by distribution # (x = \"a\" mixes with y = \"a\" and \"b\") cor_cramer(   x = c(\"a\", \"a\", \"a\", \"c\"),   y = c(\"a\", \"a\", \"b\", \"b\") ) #> [1] 0  # numeric inputs are coerced to character internally cor_cramer(   x = c(1, 1, 2, 3),   y = c(1, 1, 2, 2) ) #> [1] 0.7071068  # logical inputs are also coerced to character cor_cramer(   x = c(TRUE, TRUE, FALSE, FALSE),   y = c(TRUE, TRUE, FALSE, FALSE) ) #> [1] 1"},{"path":"https://blasbenito.github.io/collinear/reference/cor_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute signed pairwise correlations dataframe — cor_df","title":"Compute signed pairwise correlations dataframe — cor_df","text":"Computes pairwise correlations predictors using appropriate methods different variable types: Numeric vs. Numeric: Pearson correlation via stats::cor(). Numeric vs. Categorical: Target-encodes categorical variable  using numeric variable reference via target_encoding_lab() leave-one-method, computes Pearson correlation. Categorical vs. Categorical: Cramer's V via cor_cramer() measure association. See cor_cramer() important notes mixing Pearson correlation Cramer's V multicollinearity analysis. Parallelization via future::plan() progress bars via progressr::handlers() supported beneficial large datasets categorical predictors. Numeric-correlations use parallelization progress bars. Example: 16 workers, 30k rows (dataframe vi), 49 numeric 12 categorical predictors (see vi_predictors), parallelization achieves 5.4x speedup (147s → 27s).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute signed pairwise correlations dataframe — cor_df","text":"","code":"cor_df(df = NULL, predictors = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute signed pairwise correlations dataframe — cor_df","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute signed pairwise correlations dataframe — cor_df","text":"dataframe columns: x: character, first predictor name. y: character, second predictor name. correlation: numeric, Pearson correlation (numeric vs. numeric numeric vs. categorical) Cramer's V (categorical vs. categorical).","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/cor_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute signed pairwise correlations dataframe — cor_df","text":"","code":"data(vi_smol)  ## OPTIONAL: parallelization setup ## irrelevant when all predictors are numeric ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  #predictors predictors = c(   \"koppen_zone\", #character   \"soil_type\", #factor   \"topo_elevation\", #numeric   \"soil_temperature_mean\" #numeric )  x <- cor_df(   df = vi_smol,   predictors = predictors ) #>  #> collinear::cor_df() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  x #>                       x                     y correlation     metric #> 1 soil_temperature_mean           koppen_zone   0.9195774    Pearson #> 2 soil_temperature_mean             soil_type   0.6306982    Pearson #> 3        topo_elevation           koppen_zone   0.5413656    Pearson #> 4        topo_elevation             soil_type   0.3458931    Pearson #> 5           koppen_zone             soil_type   0.3146128 Cramer's V #> 6        topo_elevation soil_temperature_mean  -0.2837184    Pearson  ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Signed pairwise correlation matrix — cor_matrix","title":"Signed pairwise correlation matrix — cor_matrix","text":"Computes square matrix pairwise correlations set numeric /categorical predictors. df already correlation dataframe generated cor_df()), function transforms correlation matrix. Otherwise, cor_df() used internally compute pairwise correlations generating matrix. Supports parallel computation via future::plan() optional progress reporting via progressr::handlers().","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Signed pairwise correlation matrix — cor_matrix","text":"","code":"cor_matrix(df = NULL, predictors = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Signed pairwise correlation matrix — cor_matrix","text":"df (required; dataframe, tibble, sf) dataframe predictors output cor_df(). Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Signed pairwise correlation matrix — cor_matrix","text":"correlation matrix","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/cor_matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Signed pairwise correlation matrix — cor_matrix","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Signed pairwise correlation matrix — cor_matrix","text":"","code":"data(vi_smol)  ## OPTIONAL: parallelization setup ## irrelevant when all predictors are numeric ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  predictors <- c(   \"koppen_zone\", #character   \"soil_type\", #factor   \"topo_elevation\", #numeric   \"soil_temperature_mean\" #numeric )  #from dataframe with predictors x <- cor_matrix(   df = vi_smol,   predictors = predictors ) #>  #> collinear::cor_matrix() #> └── collinear::cor_df() #>     └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::cor_matrix() #> └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  x #>                       koppen_zone soil_temperature_mean soil_type #> koppen_zone             1.0000000             0.9195774 0.3146128 #> soil_temperature_mean   0.9195774             1.0000000 0.6306982 #> soil_type               0.3146128             0.6306982 1.0000000 #> topo_elevation          0.5413656            -0.2837184 0.3458931 #>                       topo_elevation #> koppen_zone                0.5413656 #> soil_temperature_mean     -0.2837184 #> soil_type                  0.3458931 #> topo_elevation             1.0000000 #> attr(,\"class\") #> [1] \"collinear_cor_matrix\" \"matrix\"               \"array\"                 #from correlation dataframe x <- cor_df(   df = vi,   predictors = predictors ) |>   cor_matrix() #>  #> collinear::cor_df() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  x #>                       koppen_zone soil_temperature_mean soil_type #> koppen_zone             1.0000000             0.9197237 0.3074300 #> soil_temperature_mean   0.9197237             1.0000000 0.6825247 #> soil_type               0.3074300             0.6825247 1.0000000 #> topo_elevation          0.5774720            -0.2613602 0.3929814 #>                       topo_elevation #> koppen_zone                0.5774720 #> soil_temperature_mean     -0.2613602 #> soil_type                  0.3929814 #> topo_elevation             1.0000000 #> attr(,\"class\") #> [1] \"collinear_cor_matrix\" \"matrix\"               \"array\"                 ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_select.html","id":null,"dir":"Reference","previous_headings":"","what":"Multicollinearity filtering by pairwise correlation threshold — cor_select","title":"Multicollinearity filtering by pairwise correlation threshold — cor_select","text":"Wraps collinear_select() automatize multicollinearity filtering via pairwise correlation dataframes numeric categorical predictors. argument max_cor determines maximum variance inflation factor allowed resulting selection predictors. argument preference_order accepts character vector predictor names ranked first last index, dataframe resulting preference_order(). two predictors vector dataframe highly collinear, one lower ranking removed. option helps protect predictors interest. provided, predictors ranked lower higher multicollinearity. Please check section Pairwise Correlation Filtering end help file details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multicollinearity filtering by pairwise correlation threshold — cor_select","text":"","code":"cor_select(   df = NULL,   response = NULL,   predictors = NULL,   preference_order = NULL,   max_cor = 0.7,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/cor_select.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multicollinearity filtering by pairwise correlation threshold — cor_select","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional; character NULL) Name one response variable df. Used exclude columns predictors NULL, filter preference_order dataframe contains several responses. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. preference_order (optional; character vector, dataframe preference_order, NULL) Prioritizes predictors preserve. max_cor (optional; numeric NULL) Maximum correlation allowed pairs predictors. Valid values 0.01 0.99, recommended values 0.5 (strict) 0.9 (permissive). Default: 0.7 quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_select.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multicollinearity filtering by pairwise correlation threshold — cor_select","text":"character vector selected predictors","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_select.html","id":"pairwise-correlation-filtering","dir":"Reference","previous_headings":"","what":"Pairwise Correlation Filtering","title":"Multicollinearity filtering by pairwise correlation threshold — cor_select","text":"cor_select computes global correlation matrix, orders predictors preference_order lower--higher summed correlations, sequentially selects predictors pairwise correlations max_cor.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/cor_select.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Multicollinearity filtering by pairwise correlation threshold — cor_select","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_select.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multicollinearity filtering by pairwise correlation threshold — cor_select","text":"","code":"data(vi_smol)  ## OPTIONAL: parallelization setup ## irrelevant when all predictors are numeric ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  #predictors predictors = c(   \"koppen_zone\", #character   \"soil_type\", #factor   \"topo_elevation\", #numeric   \"soil_temperature_mean\" #numeric )  #predictors ordered from lower to higher multicollinearity x <- cor_select(   df = vi_smol,   predictors = predictors,   max_cor = 0.7 ) #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::cor_matrix() #>         └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_preference_order() #>         └── collinear::preference_order(): ranking 4 'predictors' from lower to higher multicollinearity. #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_preference_order() #>         └── collinear::preference_order() #>             └── collinear::cor_matrix() #>                 └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  x #> [1] \"topo_elevation\" \"soil_type\"      \"koppen_zone\"    #> attr(,\"validated\") #> [1] TRUE   #with custom preference order x <- cor_select(   df = vi_smol,   predictors = predictors,   preference_order = c(     \"koppen_zone\",     \"soil_type\"   ),   max_cor = 0.7 ) #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::cor_matrix() #>         └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_preference_order() #>         └── collinear::preference_order(): ranking 2 'predictors' from lower to higher multicollinearity.  x #> [1] \"koppen_zone\"    \"soil_type\"      \"topo_elevation\" #> attr(,\"validated\") #> [1] TRUE  #with automated preference order df_preference <- preference_order(   df = vi_smol,   response = \"vi_numeric\",   predictors = predictors ) #>  #> collinear::preference_order() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::preference_order() #> └── collinear::f_auto(): selected function 'f_numeric_rf()' to compute preference order.  df_preference #>     response             predictor            f    metric  score rank #> 1 vi_numeric           koppen_zone f_numeric_rf R-squared 0.8174    1 #> 2 vi_numeric             soil_type f_numeric_rf R-squared 0.6249    2 #> 3 vi_numeric soil_temperature_mean f_numeric_rf R-squared 0.4201    3 #> 4 vi_numeric        topo_elevation f_numeric_rf R-squared 0.3754    4  x <- cor_select(   df = vi_smol,   predictors = predictors,   preference_order = df_preference,   max_cor = 0.7 ) #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::cor_matrix() #>         └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  x #> [1] \"koppen_zone\"    \"soil_type\"      \"topo_elevation\" #> attr(,\"validated\") #> [1] TRUE  #OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute summary statistics for absolute pairwise correlations — cor_stats","title":"Compute summary statistics for absolute pairwise correlations — cor_stats","text":"Computes minimum, mean, maximum, quantiles 0.05, 0.25, median (0.5), 0.75, 0.95 absolute values column \"correlation\" output cor_df().","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute summary statistics for absolute pairwise correlations — cor_stats","text":"","code":"cor_stats(df = NULL, predictors = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/cor_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute summary statistics for absolute pairwise correlations — cor_stats","text":"df (required; dataframe, tibble, sf) dataframe predictors output cor_df(). Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/cor_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute summary statistics for absolute pairwise correlations — cor_stats","text":"dataframe columns method (value \"correlation\"), statistic value","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/cor_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute summary statistics for absolute pairwise correlations — cor_stats","text":"","code":"data(   vi_smol,   vi_predictors_numeric   )  ## OPTIONAL: parallelization setup ## irrelevant when all predictors are numeric ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  x <- cor_stats(   df = vi_smol,   predictors = vi_predictors_numeric )  x #>        method     statistic     value #> 1 correlation             n 1081.0000 #> 2 correlation       minimum    0.0011 #> 3 correlation quantile_0.05    0.0426 #> 4 correlation quantile_0.25    0.1817 #> 5 correlation          mean    0.3980 #> 6 correlation        median    0.3610 #> 7 correlation quantile_0.75    0.6184 #> 8 correlation quantile_0.95    0.8264 #> 9 correlation       maximum    0.9893  ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/drop_geometry_column.html","id":null,"dir":"Reference","previous_headings":"","what":"Removes geometry Column From sf Dataframes — drop_geometry_column","title":"Removes geometry Column From sf Dataframes — drop_geometry_column","text":"Remove geometry column sf objects","code":""},{"path":"https://blasbenito.github.io/collinear/reference/drop_geometry_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Removes geometry Column From sf Dataframes — drop_geometry_column","text":"","code":"drop_geometry_column(df = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/drop_geometry_column.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Removes geometry Column From sf Dataframes — drop_geometry_column","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/drop_geometry_column.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Removes geometry Column From sf Dataframes — drop_geometry_column","text":"dataframe","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/drop_geometry_column.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Removes geometry Column From sf Dataframes — drop_geometry_column","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/drop_geometry_column.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Removes geometry Column From sf Dataframes — drop_geometry_column","text":"","code":"data(vi_smol)  #creating fake geometry column without sf loaded vi_smol$geometry <- NA attr(   x = vi_smol,   which = \"sf_column\"   ) <- \"geometry\"  #check new attribute attributes(vi_smol)$sf_column #> [1] \"geometry\"  #drop geometry column df <- drop_geometry_column(   df = vi_smol   ) #>  #> collinear::drop_geometry_column(): dropping geometry column from 'df'.  #checking that the geometry was droppped \"geometry\" %in% colnames(df) #> [1] FALSE attributes(df)$sf_column #> NULL"},{"path":"https://blasbenito.github.io/collinear/reference/experiment_adaptive_thresholds.html","id":null,"dir":"Reference","previous_headings":"","what":"Dataframe resulting from experiment to test the automatic selection of multicollinearity thresholds — experiment_adaptive_thresholds","title":"Dataframe resulting from experiment to test the automatic selection of multicollinearity thresholds — experiment_adaptive_thresholds","text":"dataframe summarizing 10,000 experiments validating adaptive multicollinearity threshold system collinear(). row records input data characteristics resulting multicollinearity metrics filtering.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/experiment_adaptive_thresholds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dataframe resulting from experiment to test the automatic selection of multicollinearity thresholds — experiment_adaptive_thresholds","text":"","code":"data(experiment_adaptive_thresholds)"},{"path":"https://blasbenito.github.io/collinear/reference/experiment_adaptive_thresholds.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Dataframe resulting from experiment to test the automatic selection of multicollinearity thresholds — experiment_adaptive_thresholds","text":"dataframe 10,000 rows 9 variables: input_rows Number rows input data subset. input_predictors Number predictors input data subset. output_predictors Number predictors retained filtering. input_cor_q75 75th percentile pairwise correlations input data. output_cor_q75 75th percentile pairwise correlations selected predictors. input_cor_max Maximum pairwise correlation input data. output_cor_max Maximum pairwise correlation selected predictors. input_vif_max Maximum VIF input data. output_vif_max Maximum VIF selected predictors.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/experiment_adaptive_thresholds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dataframe resulting from experiment to test the automatic selection of multicollinearity thresholds — experiment_adaptive_thresholds","text":"source data synthetic dataframe 500 columns 10,000 rows generated using distantia::zoo_simulate() correlated time series (independent = FALSE, seasons = 0). iteration randomly subsets 10-100 predictors 30-100 rows per predictor, applies collinear() automatic threshold configuration assess: Whether output VIF stays bounded ~2.5 ~7.5 system adapts different correlation structures predictor retention scales input size","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/experiment_adaptive_thresholds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dataframe resulting from experiment to test the automatic selection of multicollinearity thresholds — experiment_adaptive_thresholds","text":"","code":"data(experiment_adaptive_thresholds) str(experiment_adaptive_thresholds) #> 'data.frame':\t10000 obs. of  9 variables: #>  $ input_rows       : int  806 495 968 1100 1530 1014 660 1248 627 1020 ... #>  $ input_predictors : int  13 11 11 11 17 13 11 13 11 15 ... #>  $ output_predictors: int  5 5 6 4 5 6 6 5 5 5 ... #>  $ input_cor_q75    : num  0.476 0.389 0.356 0.583 0.663 ... #>  $ output_cor_q75   : num  0.25 0.162 0.251 0.303 0.235 ... #>  $ input_cor_max    : num  0.927 0.819 0.85 0.815 0.942 ... #>  $ output_cor_max   : num  0.336 0.379 0.36 0.458 0.423 ... #>  $ input_vif_max    : num  27.69 10.37 9.71 8.7 30.47 ... #>  $ output_vif_max   : num  1.25 1.26 1.31 1.32 1.32 ..."},{"path":"https://blasbenito.github.io/collinear/reference/experiment_cor_vs_vif.html","id":null,"dir":"Reference","previous_headings":"","what":"Dataframe with results of experiment comparing correlation and VIF thresholds — experiment_cor_vs_vif","title":"Dataframe with results of experiment comparing correlation and VIF thresholds — experiment_cor_vs_vif","text":"dataframe summarizing 10,000 experiments comparing output cor_select() vif_select(). row records input sampling parameters resulting feature-selection metrics.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/experiment_cor_vs_vif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dataframe with results of experiment comparing correlation and VIF thresholds — experiment_cor_vs_vif","text":"","code":"data(experiment_cor_vs_vif)"},{"path":"https://blasbenito.github.io/collinear/reference/experiment_cor_vs_vif.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Dataframe with results of experiment comparing correlation and VIF thresholds — experiment_cor_vs_vif","text":"dataframe 10,000 rows 6 variables: input_rows Number rows input data subset. input_predictors Number predictors input data subset. output_predictors Number predictors selected vif_select() best-matching max_vif. max_cor Maximum allowed pairwise correlation supplied cor_select(). max_vif VIF threshold vif_select() produced highest Jaccard similarity cor_select() given max_cor. out_selection_jaccard Jaccard similarity predictors selected cor_select() vif_select().","code":""},{"path":"https://blasbenito.github.io/collinear/reference/experiment_cor_vs_vif.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dataframe with results of experiment comparing correlation and VIF thresholds — experiment_cor_vs_vif","text":"source data synthetic dataframe 500 columns 10,000 rows generated using distantia::zoo_simulate() correlated time series (independent = FALSE). iteration randomly subsets 10-50 predictors 30-100 rows per predictor, applies cor_select() random max_cor threshold, finds max_vif value maximizes Jaccard similarity two selections.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/experiment_cor_vs_vif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dataframe with results of experiment comparing correlation and VIF thresholds — experiment_cor_vs_vif","text":"","code":"data(experiment_cor_vs_vif) str(experiment_cor_vs_vif) #> 'data.frame':\t10000 obs. of  6 variables: #>  $ input_rows           : num  1764 2250 1960 2392 1488 ... #>  $ input_predictors     : num  42 45 40 26 48 47 49 40 43 40 ... #>  $ output_predictors    : int  2 2 2 2 5 6 6 5 5 6 ... #>  $ max_cor              : num  0.1 0.1 0.12 0.14 0.14 0.12 0.1 0.13 0.14 0.13 ... #>  $ max_vif              : num  1 1 1 1 1.2 1.2 1.3 1.1 1.1 1.2 ... #>  $ out_selection_jaccard: num  0.25 0.25 0.25 0.25 0.286 ..."},{"path":"https://blasbenito.github.io/collinear/reference/f_auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic selection of predictor scoring method — f_auto","title":"Automatic selection of predictor scoring method — f_auto","text":"Internal function select proper f_...() function compute preference order depending types response variable predictors. selection criteria available dataframe generated f_auto_rules().","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic selection of predictor scoring method — f_auto","text":"","code":"f_auto(df = NULL, response = NULL, predictors = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatic selection of predictor scoring method — f_auto","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional, character string) Name response variable df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatic selection of predictor scoring method — f_auto","text":"function name","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_auto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatic selection of predictor scoring method — f_auto","text":"","code":"data(   vi_smol,   vi_predictors_numeric,   vi_predictors_categorical,   vi_predictors   )  f_auto(   df = vi_smol,   response = \"vi_numeric\",   predictors = vi_predictors_numeric   ) #>  #> collinear::f_auto(): selected function 'f_numeric_glm()' to compute preference order. #> [1] \"f_numeric_glm\"  f_auto(   df = vi_smol,   response = \"vi_binomial\",   predictors = vi_predictors_numeric   ) #>  #> collinear::f_auto(): selected function 'f_binomial_glm()' to compute preference order. #> [1] \"f_binomial_glm\"  f_auto(   df = vi_smol,   response = \"vi_categorical\",   predictors = vi_predictors_categorical   ) #>  #> collinear::f_auto() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - vi_categorical #>  - koppen_zone #>  - koppen_group #>  - koppen_description #>  - biogeo_ecoregion #>  - biogeo_biome #>  - biogeo_realm #>  - country_name #>  - continent #>  - region #>  - subregion #>  #> collinear::f_auto(): selected function 'f_categorical_rf()' to compute preference order. #> [1] \"f_categorical_rf\""},{"path":"https://blasbenito.github.io/collinear/reference/f_auto_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Decision rules for f_auto() — f_auto_rules","title":"Decision rules for f_auto() — f_auto_rules","text":"Dataframe rules used f_auto() select function f f_functions() compute preference order preference_order(). cases, random forest selected base model provide homogeneous results across case types.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_auto_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decision rules for f_auto() — f_auto_rules","text":"","code":"f_auto_rules()"},{"path":"https://blasbenito.github.io/collinear/reference/f_auto_rules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decision rules for f_auto() — f_auto_rules","text":"dataframe","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_auto_rules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Decision rules for f_auto() — f_auto_rules","text":"","code":"f_auto_rules() #>                name     response_type predictors_type #> 1     f_numeric_glm continuous-binary         numeric #> 2      f_numeric_rf continuous-binary     categorical #> 3      f_numeric_rf continuous-binary           mixed #> 4     f_numeric_glm    continuous-low         numeric #> 5      f_numeric_rf    continuous-low     categorical #> 6      f_numeric_rf    continuous-low           mixed #> 7     f_numeric_glm   continuous-high         numeric #> 8      f_numeric_rf   continuous-high     categorical #> 9      f_numeric_rf   continuous-high           mixed #> 10   f_binomial_glm  integer-binomial         numeric #> 11    f_binomial_rf  integer-binomial     categorical #> 12    f_binomial_rf  integer-binomial           mixed #> 13      f_count_glm    integer-binary         numeric #> 14       f_count_rf    integer-binary     categorical #> 15       f_count_rf    integer-binary           mixed #> 16      f_count_glm       integer-low         numeric #> 17       f_count_rf       integer-low     categorical #> 18       f_count_rf       integer-low           mixed #> 19      f_count_glm      integer-high         numeric #> 20       f_count_rf      integer-high     categorical #> 21       f_count_rf      integer-high           mixed #> 22 f_categorical_rf       categorical         numeric #> 23 f_categorical_rf       categorical           mixed #> 24 f_categorical_rf       categorical     categorical"},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Area under the curve of binomial GAM predictions vs. observations — f_binomial_gam","title":"Area under the curve of binomial GAM predictions vs. observations — f_binomial_gam","text":"Fits Quasibinomial GAM model y ~ s(x) (y ~ x x non-numeric) binomial response y (values 0 1) numeric, character factor predictor x using mgcv::gam() returns area ROC curve observed responses model predictions (see score_auc()). Cases weighted case_weights() prevent issues arising class imbalance. Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area under the curve of binomial GAM predictions vs. observations — f_binomial_gam","text":"","code":"f_binomial_gam(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area under the curve of binomial GAM predictions vs. observations — f_binomial_gam","text":"df (required, dataframe) columns: \"x\": (numeric, character, factor) predictor. \"y\" (integer) binomial response unique values 0 1. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area under the curve of binomial GAM predictions vs. observations — f_binomial_gam","text":"numeric numeric vector: AUC","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area under the curve of binomial GAM predictions vs. observations — f_binomial_gam","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_binomial\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_binomial_gam(df = df) #> [1] 0.7958704  #cross-validation f_binomial_gam(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.7405760 0.7577502 0.7527259 0.7765308 0.7751319 0.7897904 0.7938672 #>  [8] 0.7890389 0.7977861 0.7474687  #categorical predictor df <- data.frame(   y = vi_smol[[\"vi_binomial\"]],   x = vi_smol[[\"koppen_zone\"]] )  f_binomial_gam(df = df) #> [1] 0.9334159"},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Area Under the Curve of Binomial GLM predictions vs. observations — f_binomial_glm","title":"Area Under the Curve of Binomial GLM predictions vs. observations — f_binomial_glm","text":"Fits Quasibinomial GLM model y ~ x binomial  response y (values 0 1) numeric, character, factor predictor x using stats::glm() returns area ROC curve observations predictions (see score_auc()). Cases weighted case_weights() prevent issues arising class imbalance. Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area Under the Curve of Binomial GLM predictions vs. observations — f_binomial_glm","text":"","code":"f_binomial_glm(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area Under the Curve of Binomial GLM predictions vs. observations — f_binomial_glm","text":"df (required, dataframe) columns: \"x\": (numeric, character, factor) predictor. \"y\" (integer) binomial response unique values 0 1. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area Under the Curve of Binomial GLM predictions vs. observations — f_binomial_glm","text":"numeric numeric vector: AUC","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_glm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area Under the Curve of Binomial GLM predictions vs. observations — f_binomial_glm","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_binomial\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_binomial_glm(df = df) #> [1] 0.7161608  #cross-validation f_binomial_glm(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.7342075 0.7601301 0.7172146 0.7097408 0.7183745 0.7152365 0.6981429 #>  [8] 0.7284071 0.7129516 0.6773125  #categorical predictor df <- data.frame(   y = vi_smol[[\"vi_binomial\"]],   x = vi_smol[[\"koppen_zone\"]] )  f_binomial_glm(df = df) #> [1] 0.9334159"},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_rf.html","id":null,"dir":"Reference","previous_headings":"","what":"Area Under the Curve of Binomial Random Forest predictions vs. observations — f_binomial_rf","title":"Area Under the Curve of Binomial Random Forest predictions vs. observations — f_binomial_rf","text":"Fits univariate random forest model y ~ x binomial (values 0 1) response y numeric, character factor predictor x using ranger::ranger() returns area ROC curve observed responses model predictions (see score_auc()). Cases weighted case_weights() prevent issues arising class imbalance. Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_rf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area Under the Curve of Binomial Random Forest predictions vs. observations — f_binomial_rf","text":"","code":"f_binomial_rf(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_rf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area Under the Curve of Binomial Random Forest predictions vs. observations — f_binomial_rf","text":"df (required, dataframe) columns: \"x\": (numeric, character, factor) predictor. \"y\" (integer) binomial response unique values 0 1. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_rf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area Under the Curve of Binomial Random Forest predictions vs. observations — f_binomial_rf","text":"numeric numeric vector: AUC","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_binomial_rf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area Under the Curve of Binomial Random Forest predictions vs. observations — f_binomial_rf","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_binomial\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_binomial_rf(df = df) #> [1] 0.8995467  #cross-validation f_binomial_rf(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.7632825 0.7761184 0.7781599 0.7363415 0.7222196 0.7676069 0.7459511 #>  [8] 0.7651879 0.7656979 0.7516886  #categorical predictor df <- data.frame(   y = vi_smol[[\"vi_binomial\"]],   x = vi_smol[[\"koppen_zone\"]] )  f_binomial_rf(df = df) #> [1] 0.9328657"},{"path":"https://blasbenito.github.io/collinear/reference/f_categorical_rf.html","id":null,"dir":"Reference","previous_headings":"","what":"Cramer's V of Categorical Random Forest predictions vs. observations — f_categorical_rf","title":"Cramer's V of Categorical Random Forest predictions vs. observations — f_categorical_rf","text":"Fits univariate random forest model y ~ x character factor response y numeric, character factor predictor x using ranger::ranger() returns Cramer's V (see cor_cramer()) observed responses model predictions. Cases weighted case_weights() prevent issues arising class imbalance. Cases weighted case_weights() prevent issues arising class imbalance. Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_categorical_rf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cramer's V of Categorical Random Forest predictions vs. observations — f_categorical_rf","text":"","code":"f_categorical_rf(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_categorical_rf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cramer's V of Categorical Random Forest predictions vs. observations — f_categorical_rf","text":"df (required, dataframe) columns: x: (numeric) numeric, character, factor predictor. y (numeric) character factor response. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_categorical_rf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cramer's V of Categorical Random Forest predictions vs. observations — f_categorical_rf","text":"numeric numeric vector: Cramer's V","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_categorical_rf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cramer's V of Categorical Random Forest predictions vs. observations — f_categorical_rf","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_factor\"]],   x = vi_smol[[\"soil_type\"]] )  #no cross-validation f_categorical_rf(df = df) #> [1] 0.4710376  #cross-validation f_categorical_rf(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.4581166 0.4632736 0.3917833 0.4351281 0.4394164 0.4704325 0.4562418 #>  [8] 0.4325661 0.4756790 0.4481384  #numeric predictor df <- data.frame(   y = vi_smol[[\"vi_categorical\"]],   x = vi_smol[[\"swi_max\"]] )  f_categorical_rf(df = df) #> [1] 0.5352031"},{"path":"https://blasbenito.github.io/collinear/reference/f_count_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"R-squared of Poisson GAM predictions vs. observations — f_count_gam","title":"R-squared of Poisson GAM predictions vs. observations — f_count_gam","text":"Fits Poisson GAM model y ~ s(x) (y ~ x x non-numeric) numeric response y numeric, character factor predictor x using mgcv::gam() returns R-squared observations predictions (see score_r2()). Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_count_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R-squared of Poisson GAM predictions vs. observations — f_count_gam","text":"","code":"f_count_gam(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_count_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R-squared of Poisson GAM predictions vs. observations — f_count_gam","text":"df (required, dataframe) columns: \"x\": (numeric, character, factor) predictor. \"y\" (integer) counts response. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_count_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R-squared of Poisson GAM predictions vs. observations — f_count_gam","text":"numeric numeric vector: R-squared","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_count_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R-squared of Poisson GAM predictions vs. observations — f_count_gam","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_counts\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_count_gam(df = df) #> [1] 0.6332293  #cross-validation f_count_gam(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.5913649 0.6492575 0.5945660 0.5675929 0.6074462 0.6699379 0.6088960 #>  [8] 0.5913863 0.6255977 0.6023129"},{"path":"https://blasbenito.github.io/collinear/reference/f_count_glm.html","id":null,"dir":"Reference","previous_headings":"","what":"R-squared of Poisson GLM predictions vs. observations — f_count_glm","title":"R-squared of Poisson GLM predictions vs. observations — f_count_glm","text":"Fits Poisson GLM model y ~ x numeric response y numeric predictor x using stats::glm() returns R-squared observations predictions (see score_r2()). Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_count_glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R-squared of Poisson GLM predictions vs. observations — f_count_glm","text":"","code":"f_count_glm(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_count_glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R-squared of Poisson GLM predictions vs. observations — f_count_glm","text":"df (required, dataframe) columns: \"x\": (numeric, character, factor) predictor. \"y\" (integer) counts response. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_count_glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R-squared of Poisson GLM predictions vs. observations — f_count_glm","text":"numeric numeric vector: R-squared","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_count_glm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R-squared of Poisson GLM predictions vs. observations — f_count_glm","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_counts\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_count_glm(df = df) #> [1] 0.4894793  #cross-validation f_count_glm(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.4866785 0.4815285 0.5095271 0.4650074 0.5030237 0.5071137 0.4820454 #>  [8] 0.5300281 0.4972431 0.4897542  #categorical predictor df <- data.frame(   y = vi_smol[[\"vi_counts\"]],   x = vi_smol[[\"koppen_zone\"]] )  f_count_glm(df = df) #> [1] 0.8194987"},{"path":"https://blasbenito.github.io/collinear/reference/f_count_rf.html","id":null,"dir":"Reference","previous_headings":"","what":"R-squared of Random Forest predictions vs. observations — f_count_rf","title":"R-squared of Random Forest predictions vs. observations — f_count_rf","text":"Fits univariate random forest model y ~ x integer response y numeric, character factor predictor x using ranger::ranger() returns R-squared observations predictions (see score_r2()). Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_count_rf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R-squared of Random Forest predictions vs. observations — f_count_rf","text":"","code":"f_count_rf(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_count_rf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R-squared of Random Forest predictions vs. observations — f_count_rf","text":"df (required, dataframe) columns: \"x\": (numeric, character, factor) predictor. \"y\" (integer) counts response. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_count_rf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R-squared of Random Forest predictions vs. observations — f_count_rf","text":"numeric numeric vector: R-squared","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_count_rf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R-squared of Random Forest predictions vs. observations — f_count_rf","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_counts\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_count_rf(df = df) #> [1] 0.7174083  #cross-validation f_count_rf(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.6020496 0.4840571 0.5607237 0.6196142 0.5985117 0.5799609 0.5634010 #>  [8] 0.5833623 0.5653907 0.6038178  #categorical predictor df <- data.frame(   y = vi_smol[[\"vi_counts\"]],   x = vi_smol[[\"koppen_zone\"]] )  f_count_rf(df = df) #> [1] 0.8173939"},{"path":"https://blasbenito.github.io/collinear/reference/f_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"List predictor scoring functions — f_functions","title":"List predictor scoring functions — f_functions","text":"List predictor scoring functions","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List predictor scoring functions — f_functions","text":"","code":"f_functions()"},{"path":"https://blasbenito.github.io/collinear/reference/f_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List predictor scoring functions — f_functions","text":"dataframe","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List predictor scoring functions — f_functions","text":"","code":"f_functions() #>                name response_type predictors_types #> 1     f_numeric_glm       numeric            mixed #> 2     f_numeric_gam       numeric          numeric #> 3      f_numeric_rf       numeric            mixed #> 4        f_count_rf       integer            mixed #> 5       f_count_glm       integer            mixed #> 6       f_count_gam       integer            mixed #> 7    f_binomial_glm      binomial            mixed #> 8    f_binomial_gam      binomial          numeric #> 9     f_binomial_rf      binomial            mixed #> 10 f_categorical_rf   categorical            mixed #>                                                                                           expression #> 1                                            stats::glm(y ~ x, family = gaussian(link = 'identity')) #> 2                                          mgcv::gam(y ~ s(x), family = gaussian(link = 'identity')) #> 3                                                                              ranger::ranger(y ~ x) #> 4                                                                              ranger::ranger(y ~ x) #> 5                                                  stats::glm(y ~ x, family = poisson(link = 'log')) #> 6                                                mgcv::gam(y ~ s(x), family = poisson(link = 'log')) #> 7               stats::glm(y ~ x, family = quasibinomial(link = 'logit'), weights = case_weights(y)) #> 8  mgcv::gam(y ~ s(x), family = quasibinomial(link = 'logit'), weights = collinear::case_weights(y)) #> 9                                   ranger::ranger(y ~ x, case.weights = collinear::case_weights(y)) #> 10                                  ranger::ranger(y ~ x, case.weights = collinear::case_weights(y)) #>        metric #> 1   R-squared #> 2   R-squared #> 3   R-squared #> 4   R-squared #> 5   R-squared #> 6   R-squared #> 7         AUC #> 8         AUC #> 9         AUC #> 10 Cramer's V"},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"R-squared of Gaussian GAM predictions vs. observations — f_numeric_gam","title":"R-squared of Gaussian GAM predictions vs. observations — f_numeric_gam","text":"Fits Gaussian GAM model y ~ s(x) (y ~ x x non-numeric) numeric response y numeric, character factor predictor x using mgcv::gam() returns R-squared observations predictions (see score_r2()). Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R-squared of Gaussian GAM predictions vs. observations — f_numeric_gam","text":"","code":"f_numeric_gam(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R-squared of Gaussian GAM predictions vs. observations — f_numeric_gam","text":"df (required, dataframe) columns: x: (numeric, character, factor) predictor. y (numeric) continuous response. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R-squared of Gaussian GAM predictions vs. observations — f_numeric_gam","text":"numeric numeric vector: R-squared","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R-squared of Gaussian GAM predictions vs. observations — f_numeric_gam","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_numeric\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_numeric_gam(df = df) #> [1] 0.6324608  #cross-validation f_numeric_gam(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.6040635 0.6127678 0.6172547 0.5820694 0.5955225 0.6285816 0.6309853 #>  [8] 0.6238063 0.5930153 0.6314616  #categorical predictor df <- data.frame(   y = vi_smol[[\"vi_numeric\"]],   x = vi_smol[[\"koppen_zone\"]] )  f_numeric_gam(df = df) #> [1] 0.8194987"},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_glm.html","id":null,"dir":"Reference","previous_headings":"","what":"R-squared of Gaussian GLM predictions vs. observations — f_numeric_glm","title":"R-squared of Gaussian GLM predictions vs. observations — f_numeric_glm","text":"Fits Gaussian GLM model y ~ x numeric response y numeric, character, factor predictor x using stats::glm() returns R-squared observations predictions (see score_r2()). Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R-squared of Gaussian GLM predictions vs. observations — f_numeric_glm","text":"","code":"f_numeric_glm(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R-squared of Gaussian GLM predictions vs. observations — f_numeric_glm","text":"df (required, dataframe) columns: x: (numeric, character, factor) predictor. y (numeric) continuous response. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R-squared of Gaussian GLM predictions vs. observations — f_numeric_glm","text":"numeric numeric vector: R-squared","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_glm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R-squared of Gaussian GLM predictions vs. observations — f_numeric_glm","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_numeric\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_numeric_glm(df = df) #> [1] 0.5549257  #cross-validation f_numeric_glm(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.5515153 0.5383230 0.5456173 0.5165563 0.5317755 0.5118719 0.5540816 #>  [8] 0.5672098 0.5911266 0.5604046  #categorical predictor df <- data.frame(   y = vi_smol[[\"vi_numeric\"]],   x = vi_smol[[\"koppen_zone\"]] )  f_numeric_glm(df = df) #> [1] 0.8194987"},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_rf.html","id":null,"dir":"Reference","previous_headings":"","what":"R-squared of Random Forest predictions vs. observations — f_numeric_rf","title":"R-squared of Random Forest predictions vs. observations — f_numeric_rf","text":"Fits univariate random forest model y ~ x numeric response y numeric, character factor predictor x using ranger::ranger() returns R-squared observed responses returns R-squared observations predictions (see score_r2()). Supports cross-validation via arguments arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 n) introduced via ellipsis (...). See preference_order() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_rf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R-squared of Random Forest predictions vs. observations — f_numeric_rf","text":"","code":"f_numeric_rf(df, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_rf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R-squared of Random Forest predictions vs. observations — f_numeric_rf","text":"df (required, dataframe) columns: x: (numeric, character, factor) predictor. y (numeric) continuous response. ... (optional) Accepts arguments cv_training_fraction (numeric 0 1) cv_iterations (integer 1 Inf) cross validation.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_rf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R-squared of Random Forest predictions vs. observations — f_numeric_rf","text":"numeric numeric vector: R-squared","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/f_numeric_rf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R-squared of Random Forest predictions vs. observations — f_numeric_rf","text":"","code":"data(vi_smol)  df <- data.frame(   y = vi_smol[[\"vi_numeric\"]],   x = vi_smol[[\"swi_max\"]] )  #no cross-validation f_numeric_rf(df = df) #> [1] 0.7174085  #cross-validation f_numeric_rf(   df = df,   cv_training_fraction = 0.5,   cv_iterations = 10   ) #>  [1] 0.5856970 0.5253044 0.5521651 0.5560779 0.5302282 0.5631309 0.5878490 #>  [8] 0.5775360 0.5966921 0.5266455  #categorical predictor df <- data.frame(   y = vi_smol[[\"vi_numeric\"]],   x = vi_smol[[\"koppen_zone\"]] )  f_numeric_rf(df = df) #> [1] 0.8173939"},{"path":"https://blasbenito.github.io/collinear/reference/gam_cor_to_vif.html","id":null,"dir":"Reference","previous_headings":"","what":"GAM describing the relationship between correlation and VIF thresholds — gam_cor_to_vif","title":"GAM describing the relationship between correlation and VIF thresholds — gam_cor_to_vif","text":"fitted generalized additive model describing max_vif function max_cor experiment_cor_vs_vif.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/gam_cor_to_vif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GAM describing the relationship between correlation and VIF thresholds — gam_cor_to_vif","text":"","code":"data(gam_cor_to_vif)"},{"path":"https://blasbenito.github.io/collinear/reference/gam_cor_to_vif.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"GAM describing the relationship between correlation and VIF thresholds — gam_cor_to_vif","text":"gam object.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/gam_cor_to_vif.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"GAM describing the relationship between correlation and VIF thresholds — gam_cor_to_vif","text":"Generated internally experiment_cor_vs_vif.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/gam_cor_to_vif.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GAM describing the relationship between correlation and VIF thresholds — gam_cor_to_vif","text":"model parameters (basis dimension k weight exponent) selected via optimization, filtering models top 90\\ final model uses squared Jaccard similarity weights emphasize cases high agreement cor_select() vif_select(). Model performance: Adjusted R-squared: 0.834 Deviance explained: 83.4\\ Effective degrees freedom smooth: ~6","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/gam_cor_to_vif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GAM describing the relationship between correlation and VIF thresholds — gam_cor_to_vif","text":"","code":"data(gam_cor_to_vif) plot(gam_cor_to_vif, shade = TRUE)"},{"path":"https://blasbenito.github.io/collinear/reference/identify_categorical_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Find valid categorical variables in a dataframe — identify_categorical_variables","title":"Find valid categorical variables in a dataframe — identify_categorical_variables","text":"Identifies valid invalid character factor variables. Invalid categorical predictors single category, many categories cases (full-cardinality).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_categorical_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find valid categorical variables in a dataframe — identify_categorical_variables","text":"","code":"identify_categorical_variables(   df = NULL,   responses = NULL,   predictors = NULL,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/identify_categorical_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find valid categorical variables in a dataframe — identify_categorical_variables","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (required, character vector) Names predictors identify. Default: NULL quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_categorical_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find valid categorical variables in a dataframe — identify_categorical_variables","text":"list: valid: character vector valid categorical predictor names. invalid: character vector invalid categorical predictor names due degenerate cardinality (1 nrow(df) categories).","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/identify_categorical_variables.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find valid categorical variables in a dataframe — identify_categorical_variables","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_categorical_variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find valid categorical variables in a dataframe — identify_categorical_variables","text":"","code":"data(vi_smol, vi_predictors)  #create an invalid categorical vi_smol$invalid_categorical <- \"a\"  x <- identify_categorical_variables(   df = vi_smol,   responses = \"vi_categorical\",   predictors = vi_predictors )  x$valid #>  [1] \"vi_categorical\"     \"koppen_zone\"        \"koppen_group\"       #>  [4] \"koppen_description\" \"soil_type\"          \"biogeo_ecoregion\"   #>  [7] \"biogeo_biome\"       \"biogeo_realm\"       \"country_name\"       #> [10] \"continent\"          \"region\"             \"subregion\"          x$invalid #> NULL"},{"path":"https://blasbenito.github.io/collinear/reference/identify_logical_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Find logical variables in a dataframe — identify_logical_variables","title":"Find logical variables in a dataframe — identify_logical_variables","text":"Identifies logical predictors excludes constant values.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_logical_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find logical variables in a dataframe — identify_logical_variables","text":"","code":"identify_logical_variables(   df = NULL,   responses = NULL,   predictors = NULL,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/identify_logical_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find logical variables in a dataframe — identify_logical_variables","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (required, character vector) Names predictors identify. Default: NULL quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_logical_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find logical variables in a dataframe — identify_logical_variables","text":"list: valid: character vector valid logical predictor names. invalid: character vector invalid logical predictor names.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/identify_logical_variables.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find logical variables in a dataframe — identify_logical_variables","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_logical_variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find logical variables in a dataframe — identify_logical_variables","text":"","code":"data(vi_smol, vi_predictors)  #invalid logical vi_smol$logical_invalid <- TRUE  #valid logical vi_smol$logical_valid <- sample(   x = c(TRUE, FALSE),   size = nrow(vi_smol),   replace = TRUE )  x <- identify_logical_variables(   df = vi_smol,   predictors = c(     vi_predictors,     \"logical_invalid\",     \"logical_valid\"   ) ) #>  #> collinear::identify_logical_variables(): invalid logical predictors due to constant values: #>  - logical_invalid  x$valid #> [1] \"logical_valid\" x$invalid #> [1] \"logical_invalid\""},{"path":"https://blasbenito.github.io/collinear/reference/identify_numeric_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Find valid numeric variables in a dataframe — identify_numeric_variables","title":"Find valid numeric variables in a dataframe — identify_numeric_variables","text":"Identifies valid numeric variables ignores constant values.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_numeric_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find valid numeric variables in a dataframe — identify_numeric_variables","text":"","code":"identify_numeric_variables(   df = NULL,   responses = NULL,   predictors = NULL,   decimals = 4,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/identify_numeric_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find valid numeric variables in a dataframe — identify_numeric_variables","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (required, character vector) Names predictors identify. Default: NULL decimals (required, integer) Number decimal places zero variance test. Smaller numbers increase number variables detected near-zero variance. Recommended values depend range numeric variables 'df'. Default: 4 quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_numeric_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find valid numeric variables in a dataframe — identify_numeric_variables","text":"list: valid: character vector valid numeric predictor names. invalid: character vector invalid numeric predictor names due near-zero variance.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/identify_numeric_variables.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find valid numeric variables in a dataframe — identify_numeric_variables","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_numeric_variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find valid numeric variables in a dataframe — identify_numeric_variables","text":"","code":"data(vi_smol, vi_predictors)  x <- identify_numeric_variables(   df = vi_smol,   responses = \"vi_numeric\",   predictors = vi_predictors )  #valid numeric predictors x$valid #>  [1] \"vi_numeric\"                 \"topo_slope\"                 #>  [3] \"topo_diversity\"             \"topo_elevation\"             #>  [5] \"swi_mean\"                   \"swi_max\"                    #>  [7] \"swi_min\"                    \"swi_range\"                  #>  [9] \"soil_temperature_mean\"      \"soil_temperature_max\"       #> [11] \"soil_temperature_min\"       \"soil_temperature_range\"     #> [13] \"soil_sand\"                  \"soil_clay\"                  #> [15] \"soil_silt\"                  \"soil_ph\"                    #> [17] \"soil_soc\"                   \"soil_nitrogen\"              #> [19] \"solar_rad_mean\"             \"solar_rad_max\"              #> [21] \"solar_rad_min\"              \"solar_rad_range\"            #> [23] \"growing_season_length\"      \"growing_season_temperature\" #> [25] \"growing_season_rainfall\"    \"growing_degree_days\"        #> [27] \"temperature_mean\"           \"temperature_max\"            #> [29] \"temperature_min\"            \"temperature_range\"          #> [31] \"temperature_seasonality\"    \"rainfall_mean\"              #> [33] \"rainfall_min\"               \"rainfall_max\"               #> [35] \"rainfall_range\"             \"evapotranspiration_mean\"    #> [37] \"evapotranspiration_max\"     \"evapotranspiration_min\"     #> [39] \"evapotranspiration_range\"   \"cloud_cover_mean\"           #> [41] \"cloud_cover_max\"            \"cloud_cover_min\"            #> [43] \"cloud_cover_range\"          \"aridity_index\"              #> [45] \"humidity_mean\"              \"humidity_max\"               #> [47] \"humidity_min\"               \"humidity_range\"              #invalid due to zero variance (none here) x$invalid #> NULL"},{"path":"https://blasbenito.github.io/collinear/reference/identify_response_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect response variable type for model selection — identify_response_type","title":"Detect response variable type for model selection — identify_response_type","text":"Used f_auto() identify type response variable select proper modelling method compute preference order. Supported types : \"continuous-binary\": decimal numbers two unique values; results warning, type difficult model. \"continuous-low\": decimal numbers 3 5 unique values; results message, type difficult model. \"continuous-high\": decimal numbers 5 unique values. \"integer-binomial\": integer 0s 1s, suitable binomial models. \"integer-binary\": integer 2 unique values 0 1; returns warning, type difficult model. \"integer-low\": integer 3 5 unique values meets specified thresholds. \"integer-high\": integer 5 unique values suitable count modelling. \"categorical\": character factor 2 levels. \"unknown\": response type determined.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_response_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect response variable type for model selection — identify_response_type","text":"","code":"identify_response_type(df = NULL, response = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/identify_response_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect response variable type for model selection — identify_response_type","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional, character string) Name response variable df. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_response_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect response variable type for model selection — identify_response_type","text":"character string: response type","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/identify_response_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect response variable type for model selection — identify_response_type","text":"","code":"data(vi_smol)  identify_response_type(   df = vi_smol,   response = \"vi_numeric\" ) #> [1] \"continuous-high\"  identify_response_type(   df = vi_smol,   response = \"vi_counts\" ) #> [1] \"integer-high\"  identify_response_type(   df = vi_smol,   response = \"vi_binomial\" ) #> [1] \"integer-binomial\"  identify_response_type(   df = vi_smol,   response = \"vi_categorical\" ) #>  #> collinear::identify_response_type() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - vi_categorical #> [1] \"categorical\"  identify_response_type(   df = vi_smol,   response = \"vi_factor\" ) #> [1] \"categorical\""},{"path":"https://blasbenito.github.io/collinear/reference/identify_valid_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Find valid numeric, categorical, and logical variables in a dataframe — identify_valid_variables","title":"Find valid numeric, categorical, and logical variables in a dataframe — identify_valid_variables","text":"Returns list names valid numeric, categorical, logical variables modelling dataframe.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_valid_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find valid numeric, categorical, and logical variables in a dataframe — identify_valid_variables","text":"","code":"identify_valid_variables(   df = NULL,   responses = NULL,   predictors = NULL,   decimals = 4,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/identify_valid_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find valid numeric, categorical, and logical variables in a dataframe — identify_valid_variables","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (required, character vector) Names predictors identify. Default: NULL decimals (required, integer) Number decimal places zero variance test. Smaller numbers increase number variables detected near-zero variance. Recommended values depend range numeric variables 'df'. Default: 4 quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_valid_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find valid numeric, categorical, and logical variables in a dataframe — identify_valid_variables","text":"list numeric: character vector numeric predictors. categorical: character vector categorical (character factor) predictors. logical: character vector logical predictors.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/identify_valid_variables.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find valid numeric, categorical, and logical variables in a dataframe — identify_valid_variables","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_valid_variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find valid numeric, categorical, and logical variables in a dataframe — identify_valid_variables","text":"","code":"data(vi_smol, vi_predictors)  x <- identify_valid_variables(   df = vi_smol,   predictors = vi_predictors )  x #> $numeric #>  [1] \"topo_slope\"                 \"topo_diversity\"             #>  [3] \"topo_elevation\"             \"swi_mean\"                   #>  [5] \"swi_max\"                    \"swi_min\"                    #>  [7] \"swi_range\"                  \"soil_temperature_mean\"      #>  [9] \"soil_temperature_max\"       \"soil_temperature_min\"       #> [11] \"soil_temperature_range\"     \"soil_sand\"                  #> [13] \"soil_clay\"                  \"soil_silt\"                  #> [15] \"soil_ph\"                    \"soil_soc\"                   #> [17] \"soil_nitrogen\"              \"solar_rad_mean\"             #> [19] \"solar_rad_max\"              \"solar_rad_min\"              #> [21] \"solar_rad_range\"            \"growing_season_length\"      #> [23] \"growing_season_temperature\" \"growing_season_rainfall\"    #> [25] \"growing_degree_days\"        \"temperature_mean\"           #> [27] \"temperature_max\"            \"temperature_min\"            #> [29] \"temperature_range\"          \"temperature_seasonality\"    #> [31] \"rainfall_mean\"              \"rainfall_min\"               #> [33] \"rainfall_max\"               \"rainfall_range\"             #> [35] \"evapotranspiration_mean\"    \"evapotranspiration_max\"     #> [37] \"evapotranspiration_min\"     \"evapotranspiration_range\"   #> [39] \"cloud_cover_mean\"           \"cloud_cover_max\"            #> [41] \"cloud_cover_min\"            \"cloud_cover_range\"          #> [43] \"aridity_index\"              \"humidity_mean\"              #> [45] \"humidity_max\"               \"humidity_min\"               #> [47] \"humidity_range\"             #>  #> $categorical #>  [1] \"koppen_zone\"        \"koppen_group\"       \"koppen_description\" #>  [4] \"soil_type\"          \"biogeo_ecoregion\"   \"biogeo_biome\"       #>  [7] \"biogeo_realm\"       \"country_name\"       \"continent\"          #> [10] \"region\"             \"subregion\"          #>"},{"path":"https://blasbenito.github.io/collinear/reference/identify_zero_variance_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Find near-zero variance variables in a dataframe — identify_zero_variance_variables","title":"Find near-zero variance variables in a dataframe — identify_zero_variance_variables","text":"Returns names near-zero variance variables modelling dataframe.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_zero_variance_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find near-zero variance variables in a dataframe — identify_zero_variance_variables","text":"","code":"identify_zero_variance_variables(   df = NULL,   responses = NULL,   predictors = NULL,   decimals = 4,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/identify_zero_variance_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find near-zero variance variables in a dataframe — identify_zero_variance_variables","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. decimals (required, integer) Number decimal places zero variance test. Smaller numbers increase number variables detected near-zero variance. Recommended values depend range numeric variables 'df'. Default: 4 quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_zero_variance_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find near-zero variance variables in a dataframe — identify_zero_variance_variables","text":"character vector: names near-zero variance columns.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/identify_zero_variance_variables.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find near-zero variance variables in a dataframe — identify_zero_variance_variables","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/identify_zero_variance_variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find near-zero variance variables in a dataframe — identify_zero_variance_variables","text":"","code":"data(vi_smol, vi_predictors)  #create zero and near variance predictors vi_smol$zero_variance <- 1 vi_smol$near_zero_variance <- runif(   n = nrow(vi_smol),   min = 0,   max = 0.0001   )   #add to vi predictors vi_predictors <- c(   vi_predictors,   \"zero_variance\",   \"near_zero_variance\" )  #identify zero variance predictors x <- identify_zero_variance_variables(   df = vi_smol,   predictors = vi_predictors ) #>  #> collinear::identify_zero_variance_variables(): invalid predictors due to near-zero variance: #>  - zero_variance #>  - near_zero_variance  x #> [1] \"zero_variance\"      \"near_zero_variance\""},{"path":"https://blasbenito.github.io/collinear/reference/model_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Build model formulas from response and predictors — model_formula","title":"Build model formulas from response and predictors — model_formula","text":"Generates model formulas dataframe, response name, vector predictors can output multicollinearity management function collinear_select() likes. Intended help fit exploratory models result multicollinearity analysis. types formulas can generate : additive: y ~ x + z polynomial: y ~ poly(x, ...) + poly(z, ...) GAM: y ~ s(x) + s(z) random effect: y ~ x + (1 \\ z)","code":""},{"path":"https://blasbenito.github.io/collinear/reference/model_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build model formulas from response and predictors — model_formula","text":"","code":"model_formula(   df = NULL,   response = NULL,   predictors = NULL,   term_f = NULL,   term_args = NULL,   random_effects = NULL,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/model_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build model formulas from response and predictors — model_formula","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional, character string) Name response variable df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. term_f (optional; string). Name function apply term formula, \"s\" mgcv::s() smoothing function, \"poly\" stats::poly(). Default: NULL term_args (optional; string). Arguments function applied term. example, \"poly\" can \"degree = 2, raw = TRUE\". Default: NULL random_effects (optional, string character vector). Names variables used random effects. element added final formula +(1 | random_effect_name). Default: NULL quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/model_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build model formulas from response and predictors — model_formula","text":"list predictors list length response higher one, character vector otherwise.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/model_formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build model formulas from response and predictors — model_formula","text":"","code":"data(   vi_smol,   vi_predictors_numeric   )  #reduce collinearity x <- collinear_select(   df = vi_smol,   predictors = vi_predictors_numeric ) #>  #> collinear::collinear_select() #> └── collinear::validate_arg_preference_order() #>     └── collinear::preference_order(): ranking 47 'predictors' from lower to higher multicollinearity.  #additive formula y <- model_formula(   df = vi_smol,   response = \"vi_numeric\",   predictors = x )  y #> vi_numeric ~ topo_elevation + topo_slope + humidity_range + topo_diversity +  #>     soil_clay + cloud_cover_range + soil_silt + rainfall_min +  #>     growing_season_temperature + swi_max + soil_nitrogen + evapotranspiration_range #> <environment: 0x55aed4112110>  #using a formula in a model m <- stats::lm(  formula = y,  data = vi_smol  )  summary(m) #>  #> Call: #> stats::lm(formula = y, data = vi_smol) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.43746 -0.06323 -0.00511  0.06252  0.28047  #>  #> Coefficients: #>                              Estimate Std. Error t value Pr(>|t|)     #> (Intercept)                 2.765e-01  5.235e-02   5.282 1.79e-07 *** #> topo_elevation             -6.039e-05  8.326e-06  -7.253 1.27e-12 *** #> topo_slope                  1.710e-03  1.607e-03   1.064 0.287743     #> humidity_range             -7.068e-03  7.024e-04 -10.064  < 2e-16 *** #> topo_diversity              4.630e-03  1.035e-03   4.473 9.22e-06 *** #> soil_clay                   9.984e-04  5.495e-04   1.817 0.069708 .   #> cloud_cover_range           1.352e-03  3.792e-04   3.564 0.000394 *** #> soil_silt                  -1.026e-03  4.380e-04  -2.342 0.019525 *   #> rainfall_min                3.945e-04  9.916e-05   3.979 7.78e-05 *** #> growing_season_temperature -2.520e-03  1.016e-03  -2.480 0.013408 *   #> swi_max                     4.917e-03  2.713e-04  18.123  < 2e-16 *** #> soil_nitrogen               1.644e-03  4.077e-03   0.403 0.686886     #> evapotranspiration_range   -1.344e-03  1.396e-04  -9.625  < 2e-16 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 0.09681 on 597 degrees of freedom #> Multiple R-squared:  0.7932,\tAdjusted R-squared:  0.789  #> F-statistic: 190.8 on 12 and 597 DF,  p-value: < 2.2e-16 #>   #classification formula (character response) y <- model_formula(   df = vi_smol,   response = \"vi_categorical\",   predictors = x )  y #> vi_categorical ~ topo_elevation + topo_slope + humidity_range +  #>     topo_diversity + soil_clay + cloud_cover_range + soil_silt +  #>     rainfall_min + growing_season_temperature + swi_max + soil_nitrogen +  #>     evapotranspiration_range #> <environment: 0x55aed4112110>   #polynomial formula (3rd degree) y <- model_formula(   df = vi_smol,   response = \"vi_numeric\",   predictors = x,   term_f = \"poly\",   term_args = \"degree = 3, raw = TRUE\" )  y #> vi_numeric ~ poly(topo_elevation, degree = 3, raw = TRUE) + poly(topo_slope,  #>     degree = 3, raw = TRUE) + poly(humidity_range, degree = 3,  #>     raw = TRUE) + poly(topo_diversity, degree = 3, raw = TRUE) +  #>     poly(soil_clay, degree = 3, raw = TRUE) + poly(cloud_cover_range,  #>     degree = 3, raw = TRUE) + poly(soil_silt, degree = 3, raw = TRUE) +  #>     poly(rainfall_min, degree = 3, raw = TRUE) + poly(growing_season_temperature,  #>     degree = 3, raw = TRUE) + poly(swi_max, degree = 3, raw = TRUE) +  #>     poly(soil_nitrogen, degree = 3, raw = TRUE) + poly(evapotranspiration_range,  #>     degree = 3, raw = TRUE) #> <environment: 0x55aed4112110>  #gam formula y <- model_formula(   df = vi_smol,   response = \"vi_numeric\",   predictors = x,   term_f = \"s\" )  y #> vi_numeric ~ s(topo_elevation) + s(topo_slope) + s(humidity_range) +  #>     s(topo_diversity) + s(soil_clay) + s(cloud_cover_range) +  #>     s(soil_silt) + s(rainfall_min) + s(growing_season_temperature) +  #>     s(swi_max) + s(soil_nitrogen) + s(evapotranspiration_range) #> <environment: 0x55aed4112110>  #random effect y <- model_formula(   df = vi_smol,   response = \"vi_numeric\",   predictors = x,   random_effects = \"country_name\" #from vi_smol$country_name )  y #> vi_numeric ~ topo_elevation + topo_slope + humidity_range + topo_diversity +  #>     soil_clay + cloud_cover_range + soil_silt + rainfall_min +  #>     growing_season_temperature + swi_max + soil_nitrogen + evapotranspiration_range +  #>     (1 | country_name) #> <environment: 0x55aed4112110>"},{"path":"https://blasbenito.github.io/collinear/reference/prediction_cor_to_vif.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction of the model gam_cor_to_vif across correlation values — prediction_cor_to_vif","title":"Prediction of the model gam_cor_to_vif across correlation values — prediction_cor_to_vif","text":"Dataframe predicted VIF threshold corresponding given correlation threshold..","code":""},{"path":"https://blasbenito.github.io/collinear/reference/prediction_cor_to_vif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction of the model gam_cor_to_vif across correlation values — prediction_cor_to_vif","text":"","code":"data(prediction_cor_to_vif)"},{"path":"https://blasbenito.github.io/collinear/reference/prediction_cor_to_vif.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Prediction of the model gam_cor_to_vif across correlation values — prediction_cor_to_vif","text":"dataframe 901 rows 2 numeric columns: max_cor Maximum allowed pairwise correlation, 0.10 1.00 steps 0.001. max_vif Predicted VIF threshold corresponding max_cor.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/prediction_cor_to_vif.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prediction of the model gam_cor_to_vif across correlation values — prediction_cor_to_vif","text":"Values generated applying mgcv::predict.gam() fitted model gam_cor_to_vif rounding three decimal places.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/prediction_cor_to_vif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction of the model gam_cor_to_vif across correlation values — prediction_cor_to_vif","text":"","code":"data(prediction_cor_to_vif) head(prediction_cor_to_vif) #>   max_cor max_vif #> 1   0.100   1.095 #> 2   0.101   1.096 #> 3   0.102   1.097 #> 4   0.103   1.099 #> 5   0.104   1.100 #> 6   0.105   1.101 plot(max_vif ~ max_cor, data = prediction_cor_to_vif, type = \"l\")"},{"path":"https://blasbenito.github.io/collinear/reference/preference_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank predictors by importance or multicollinearity — preference_order","title":"Rank predictors by importance or multicollinearity — preference_order","text":"Generates valid input argument preference_order functions vif_select(), cor_select(), collinear_select(), collinear(). argument helps preserve important predictors multicollinearity filtering. function works two different ways: f NULL, ranks predictors lower higher multicollinearity, computed one minus average Pearson correlation given predictor others. option useful goal limit redundancy large dataset specific model train mind. responses f NULL, ranks predictors strength association response based evaluation univariate models. best possible option end-goal training model. argument f (requires valid resopnses argument) defines strength association response predictor computed. default calls f_auto(), uses f_auto_rules() select suitable function depending types response predictors. option designed provide sensible, general-purpose defaults optimized speed stability rather specific modeling approach. fine-tuned control, package offers following f functions (see f_functions()): Numeric response: f_numeric_glm(): Pearson's R-squared response versus predictions Gaussian GLM. f_numeric_gam(): GAM model fitted mgcv::gam(). f_numeric_rf(): Random Forest model fitted ranger::ranger(). Integer counts response: f_count_glm(): Pearson's R-squared Poisson GLM. f_count_gam(): Poisson GAM. f_count_rf(): Random Forest model fitted ranger::ranger(). Binomial response (1 0): f_binomial_glm(): AUC Quasibinomial GLM weighted cases. f_binomial_gam(): AUC Quasibinomial GAM weighted cases. f_binomial_rf(): AUC Random Forest model weighted cases. Categorical response: f_categorical_rf(): Cramer's V response predictions classification Random Forest model. functions accept cross-validation setup via arguments cv_iterations cv_training_fraction. Additionally, argument f accepts custom function taking dataframe columns \"x\" (predictor) \"y\" (response) returning numeric indicator association. Accepts parallelization setup via future::plan() progress bar via progressr::handlers() (see examples). Accepts character vector response variables input argument responses. one response provided, output named list preference data frames.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/preference_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank predictors by importance or multicollinearity — preference_order","text":"","code":"preference_order(   df = NULL,   responses = NULL,   predictors = NULL,   f = f_auto,   cv_training_fraction = 1,   cv_iterations = 1,   seed = 1,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/preference_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank predictors by importance or multicollinearity — preference_order","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. f (optional: function name) Unquoted function name without parenthesis (see f_functions). default calls f_auto(), selects suitable function depending nature response predictors. Set NULL responses = NULL. NULL, predictors ranked lower higher multicollinearity. Default: f_auto cv_training_fraction (optional, numeric) Value 0.1 1 defining training faction used cross-validation. 1 (default), cross-validation performed, resulting metric computed observations predictions. Automatically set 1 cv_iterations = 1. Default: 1 cv_iterations (optional, integer) Number cross-validation iterations perform. recommended range lies 30 100. general, smaller datasets large values cv_training_fraction require iterations achieve stability. Automatically set 1 cv_training_fraction = 1. Default: 1 seed (optional, integer) Random seed, required reproducibility using cross-validation random forest models. Default: 1 quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/preference_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank predictors by importance or multicollinearity — preference_order","text":"dataframe: response: character, response name, , \"none\" otherwise. predictor: character, name predictor. f: name function used compute preference order. argument f NULL, value \"stats::cor()\" added column. metric: name metric used assess strength association. Usually one \"R-squared\", \"AUC\" (Area ROC Curve), \"Cramer's V\". f custom function f_functions(), metric set \"custom\". f NULL, \"1 - R-squared\" returned column. score: value metric returned f assess association response given predictor. rank: integer value indicating rank predictor.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/preference_order.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rank predictors by importance or multicollinearity — preference_order","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/preference_order.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rank predictors by importance or multicollinearity — preference_order","text":"","code":"#load example data data(   vi_smol,   vi_predictors_numeric )  ##OPTIONAL: parallelization setup # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ##OPTIONAL: progress bar ##does not work in R examples # progressr::handlers(global = TRUE)  #ranking predictors from lower to higher multicollinearity #------------------------------------------------ x <- preference_order(   df = vi_smol,   responses = NULL, #default value   predictors = vi_predictors_numeric[1:10],   f = NULL #must be explicit ) #>  #> collinear::preference_order(): ranking 10 'predictors' from lower to higher multicollinearity.  x #>    response             predictor            f        metric  score rank #> 1      none        topo_elevation stats::cor() 1 - R-squared 0.8184    1 #> 2      none        topo_diversity stats::cor() 1 - R-squared 0.8183    2 #> 3      none            topo_slope stats::cor() 1 - R-squared 0.8001    3 #> 4      none  soil_temperature_min stats::cor() 1 - R-squared 0.7434    4 #> 5      none             swi_range stats::cor() 1 - R-squared 0.7387    5 #> 6      none soil_temperature_mean stats::cor() 1 - R-squared 0.6534    6 #> 7      none              swi_mean stats::cor() 1 - R-squared 0.6272    7 #> 8      none               swi_max stats::cor() 1 - R-squared 0.6259    8 #> 9      none               swi_min stats::cor() 1 - R-squared 0.6170    9 #> 10     none  soil_temperature_max stats::cor() 1 - R-squared 0.6021   10  #automatic selection of ranking function #------------------------------------------------ x <- preference_order(   df = vi_smol,   responses = c(\"vi_numeric\", \"vi_categorical\"),   predictors = vi_predictors_numeric[1:10],   f = f_auto   ) #>  #> collinear::preference_order() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - vi_categorical #>  #> collinear::preference_order() #> └── collinear::validate_arg_responses(): argument 'response' must be of length 1, using response:  #>  - vi_numeric #>  #> collinear::preference_order(): processing response 'vi_numeric'. #> ---------------------------------------------------------------- #>  #> collinear::preference_order() #> └── collinear::f_auto(): selected function 'f_numeric_glm()' to compute preference order. #>  #> collinear::preference_order(): processing response 'vi_categorical'. #> -------------------------------------------------------------------- #>  #> collinear::preference_order() #> └── collinear::f_auto(): selected function 'f_categorical_rf()' to compute preference order.  x #>          response             predictor                f     metric  score rank #> 1      vi_numeric              swi_mean    f_numeric_glm  R-squared 0.7182    1 #> 2      vi_numeric               swi_max    f_numeric_glm  R-squared 0.5549    2 #> 3      vi_numeric  soil_temperature_max    f_numeric_glm  R-squared 0.5462    3 #> 4      vi_numeric             swi_range    f_numeric_glm  R-squared 0.4225    4 #> 5      vi_numeric               swi_min    f_numeric_glm  R-squared 0.2130    5 #> 6      vi_numeric  soil_temperature_min    f_numeric_glm  R-squared 0.0972    6 #> 7      vi_numeric        topo_diversity    f_numeric_glm  R-squared 0.0663    7 #> 8      vi_numeric        topo_elevation    f_numeric_glm  R-squared 0.0351    8 #> 9      vi_numeric            topo_slope    f_numeric_glm  R-squared 0.0176    9 #> 10     vi_numeric soil_temperature_mean    f_numeric_glm  R-squared 0.0151   10 #> 11 vi_categorical              swi_mean f_categorical_rf Cramer's V 0.5881    1 #> 12 vi_categorical  soil_temperature_max f_categorical_rf Cramer's V 0.5679    2 #> 13 vi_categorical               swi_max f_categorical_rf Cramer's V 0.5363    3 #> 14 vi_categorical             swi_range f_categorical_rf Cramer's V 0.4871    4 #> 15 vi_categorical               swi_min f_categorical_rf Cramer's V 0.4491    5 #> 16 vi_categorical soil_temperature_mean f_categorical_rf Cramer's V 0.4015    6 #> 17 vi_categorical  soil_temperature_min f_categorical_rf Cramer's V 0.3878    7 #> 18 vi_categorical        topo_elevation f_categorical_rf Cramer's V 0.3287    8 #> 19 vi_categorical        topo_diversity f_categorical_rf Cramer's V 0.1992    9 #> 20 vi_categorical            topo_slope f_categorical_rf Cramer's V 0.1150   10  #user selection of ranking function #------------------------------------------------ #Poisson GLM for a integer counts response x <- preference_order(   df = vi_smol,   responses = \"vi_binomial\",   predictors = vi_predictors_numeric[1:10],   f = f_binomial_glm )  x #>       response             predictor              f metric  score rank #> 1  vi_binomial              swi_mean f_binomial_glm    AUC 0.8800    1 #> 2  vi_binomial  soil_temperature_max f_binomial_glm    AUC 0.8380    2 #> 3  vi_binomial             swi_range f_binomial_glm    AUC 0.7452    3 #> 4  vi_binomial  soil_temperature_min f_binomial_glm    AUC 0.7445    4 #> 5  vi_binomial               swi_min f_binomial_glm    AUC 0.7230    5 #> 6  vi_binomial               swi_max f_binomial_glm    AUC 0.7162    6 #> 7  vi_binomial        topo_diversity f_binomial_glm    AUC 0.6804    7 #> 8  vi_binomial            topo_slope f_binomial_glm    AUC 0.5975    8 #> 9  vi_binomial        topo_elevation f_binomial_glm    AUC 0.5508    9 #> 10 vi_binomial soil_temperature_mean f_binomial_glm    AUC 0.4432   10  #cross-validation #------------------------------------------------ x <- preference_order(   df = vi_smol,   responses = \"vi_binomial\",   predictors = vi_predictors_numeric[1:10],   f = f_binomial_glm,   cv_training_fraction = 0.5,   cv_iterations = 10 )  x #>       response             predictor              f metric  score rank #> 1  vi_binomial              swi_mean f_binomial_glm    AUC 0.8811    1 #> 2  vi_binomial  soil_temperature_max f_binomial_glm    AUC 0.8357    2 #> 3  vi_binomial  soil_temperature_min f_binomial_glm    AUC 0.7505    3 #> 4  vi_binomial             swi_range f_binomial_glm    AUC 0.7434    4 #> 5  vi_binomial               swi_min f_binomial_glm    AUC 0.7229    5 #> 6  vi_binomial               swi_max f_binomial_glm    AUC 0.7174    6 #> 7  vi_binomial        topo_diversity f_binomial_glm    AUC 0.6845    7 #> 8  vi_binomial            topo_slope f_binomial_glm    AUC 0.5911    8 #> 9  vi_binomial        topo_elevation f_binomial_glm    AUC 0.5505    9 #> 10 vi_binomial soil_temperature_mean f_binomial_glm    AUC 0.4615   10  #custom pairwise correlation function #------------------------------------------------ #custom functions need the ellipsis argument f_rsquared <- function(df, ...){     stats::cor(       x = df$x,       y = df$y,       use = \"complete.obs\"     )^2 }  x <- preference_order(   df = vi_smol,   responses = \"vi_numeric\",   predictors = vi_predictors_numeric[1:10],   f = f_rsquared )  x #>      response             predictor          f metric  score rank #> 1  vi_numeric              swi_mean f_rsquared custom 0.7182    1 #> 2  vi_numeric               swi_max f_rsquared custom 0.5549    2 #> 3  vi_numeric  soil_temperature_max f_rsquared custom 0.5462    3 #> 4  vi_numeric             swi_range f_rsquared custom 0.4225    4 #> 5  vi_numeric               swi_min f_rsquared custom 0.2130    5 #> 6  vi_numeric  soil_temperature_min f_rsquared custom 0.0972    6 #> 7  vi_numeric        topo_diversity f_rsquared custom 0.0663    7 #> 8  vi_numeric        topo_elevation f_rsquared custom 0.0351    8 #> 9  vi_numeric            topo_slope f_rsquared custom 0.0176    9 #> 10 vi_numeric soil_temperature_mean f_rsquared custom 0.0151   10  #resetting to sequential processing #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/print.collinear_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Print all collinear selection results of collinear() — print.collinear_output","title":"Print all collinear selection results of collinear() — print.collinear_output","text":"Print collinear selection results collinear()","code":""},{"path":"https://blasbenito.github.io/collinear/reference/print.collinear_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print all collinear selection results of collinear() — print.collinear_output","text":"","code":"# S3 method for class 'collinear_output' print(x = NULL, n = 5, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/print.collinear_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print all collinear selection results of collinear() — print.collinear_output","text":"x (required, list class class.collinear_output) Object print. Default: NULL n (optional, integer) Maximum printed vector length. Default: 5. ... Ignored, kept consistency generic.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/print.collinear_selection.html","id":null,"dir":"Reference","previous_headings":"","what":"Print single selection results from collinear — print.collinear_selection","title":"Print single selection results from collinear — print.collinear_selection","text":"Print single selection results collinear","code":""},{"path":"https://blasbenito.github.io/collinear/reference/print.collinear_selection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print single selection results from collinear — print.collinear_selection","text":"","code":"# S3 method for class 'collinear_selection' print(x = NULL, n = 5, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/print.collinear_selection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print single selection results from collinear — print.collinear_selection","text":"x (required, sub-list output collinear()) Object print. Default: NULL n (optional, integer) Maximum printed vector length. Default: 5. ... Ignored, kept consistency generic.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/score_auc.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute area under the ROC curve between binomial observations and probabilistic predictions — score_auc","title":"Compute area under the ROC curve between binomial observations and probabilistic predictions — score_auc","text":"Internal function compute AUC binomial models within preference_order(). Used within f_binomial_glm(), f_binomial_gam(), f_binomial_rf(). function build speed check inputs.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/score_auc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute area under the ROC curve between binomial observations and probabilistic predictions — score_auc","text":"","code":"score_auc(o = NULL, p = NULL, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/score_auc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute area under the ROC curve between binomial observations and probabilistic predictions — score_auc","text":"o (required, numeric vector) Binomial observations (values 0 1). Default: NULL p (required, numeric vector) Prediction binomial model range 0-1. Default: NULL ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/score_auc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute area under the ROC curve between binomial observations and probabilistic predictions — score_auc","text":"numeric: Area ROC Curve","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/score_auc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute area under the ROC curve between binomial observations and probabilistic predictions — score_auc","text":"","code":"score_auc(     o = c(1, 1, 1, 1, 0, 0, 0),     p = c(1, 0.8, 0.7, 0.6, 0.5, 0.6, 0.7)   ) #> [1] 0.8333333"},{"path":"https://blasbenito.github.io/collinear/reference/score_cramer.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Cramer's V between categorical observations and predictions — score_cramer","title":"Compute Cramer's V between categorical observations and predictions — score_cramer","text":"Internal function compute Cramer's V categorical observations versus categorical model predictions. Please read help file cor_cramer() details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/score_cramer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Cramer's V between categorical observations and predictions — score_cramer","text":"","code":"score_cramer(o = NULL, p = NULL, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/score_cramer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Cramer's V between categorical observations and predictions — score_cramer","text":"o (required; character vector) categorical observations. Default: NULL p (required; character vector) categorical predictions. Default: NULL ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/score_cramer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Cramer's V between categorical observations and predictions — score_cramer","text":"numeric: Cramer's V","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/score_cramer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Cramer's V between categorical observations and predictions — score_cramer","text":"","code":"score_cramer(  o = c(\"a\", \"a\", \"b\", \"c\", \"c\"),  p = c(\"a\", \"b\", \"b\", \"c\", \"c\")  ) #> [1] 0.5"},{"path":"https://blasbenito.github.io/collinear/reference/score_r2.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute R-squared between numeric observations and predictions — score_r2","title":"Compute R-squared between numeric observations and predictions — score_r2","text":"Internal function compute R-squared observations versus predictions via stats::cor(). Used within f_numeric_glm(), f_numeric_gam(), f_numeric_rf(), f_count_glm(), f_count_gam().","code":""},{"path":"https://blasbenito.github.io/collinear/reference/score_r2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute R-squared between numeric observations and predictions — score_r2","text":"","code":"score_r2(o = NULL, p = NULL, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/score_r2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute R-squared between numeric observations and predictions — score_r2","text":"o (required, numeric vector) Observations. Default: NULL p (required, numeric vector) Predictions. Default: NULL ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/score_r2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute R-squared between numeric observations and predictions — score_r2","text":"numeric: Pearson R-squared","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/score_r2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute R-squared between numeric observations and predictions — score_r2","text":"","code":"score_r2(     o = c(1, 1, 1, 0.5, 0.5, 0, 0),     p = c(1, 0.8, 0.7, 0.6, 0.5, 0.1, 0)   ) #> [1] 0.9077973"},{"path":"https://blasbenito.github.io/collinear/reference/step_collinear.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidymodels recipe step for multicollinearity filtering — step_collinear","title":"Tidymodels recipe step for multicollinearity filtering — step_collinear","text":"Adds step recipe created recipes::recipe()]+ apply multicollinearity filtering via collinear(). function requires recipes package installed. Unlike collinear(), wrapper perform target encoding, default value argument quiet TRUE.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/step_collinear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidymodels recipe step for multicollinearity filtering — step_collinear","text":"","code":"step_collinear(   recipe,   ...,   role = NA,   trained = FALSE,   options = list(),   selected = NULL,   skip = FALSE,   keep_original_cols = FALSE,   id = recipes::rand_id(\"collinear\") )  # S3 method for class 'step_collinear' prep(x = NULL, training = NULL, info = NULL, ...)  # S3 method for class 'step_collinear' bake(object = NULL, new_data = NULL, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/step_collinear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidymodels recipe step for multicollinearity filtering — step_collinear","text":"recipe (required, recipe) recipe object step added. ... (optional) Additional arguments (currently ignored). role (optional, character) used step since new variables created. Default: NA trained (optional, logical) Indicates step trained. Default: FALSE options (optional, list) Named list arguments passed collinear(). Common options include: max_cor: Maximum correlation threshold. NULL (default), automatically set based median correlation predictors. max_vif: Maximum VIF threshold. NULL (default), automatically set match auto-computed max_cor. preference_order: Vector predictor names priority order. f: Function compute preference order (default: f_auto) quiet: Suppress messages (default: TRUE) Note: encoding_method supported step. automatic threshold selection adapts dataset's correlation structure. selected (character vector) Predictors retained filtering. Populated training used baking. Default: NULL skip (optional, logical) Trigger skip step baking. Default: FALSE. keep_original_cols (optional, logical) Whether keep original columns. Default: FALSE. id (optional, character) Unique identifier step. x (required, step_collinear object) step trained. Default: NULL training (required, data.frame) training dataset used estimate quantities. info (optional, data.frame) Preprocessed information variables training. Default: NULL object (required, step_collinear object) trained step. Default: NULL new_data (required, data.frame) New data apply step . Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/step_collinear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidymodels recipe step for multicollinearity filtering — step_collinear","text":"Updated recipe new step.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/step_collinear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tidymodels recipe step for multicollinearity filtering — step_collinear","text":"","code":"if (FALSE) { # \\dontrun{ if(requireNamespace(\"recipes\", quietly = TRUE) &&     requireNamespace(\"parsnip\", quietly = TRUE) &&     requireNamespace(\"workflows\", quietly = TRUE)     ){  data(   vi_smol,   vi_predictors_numeric   )  # model formula vi_formula <- collinear::model_formula(   df = vi_smol,   response = \"vi_numeric\",   predictors = vi_predictors_numeric )  # recipe vi_recipe <- recipes::recipe(   formula = vi_formula,   data = vi_smol   ) |>   #multicollinearity filtering   collinear::step_collinear(     recipes::all_predictors(),     options = list(       max_cor = 0.7,       max_vif = 5,       f = collinear::f_numeric_glm       )   ) |>   #normalization   recipes::step_normalize(     recipes::all_predictors()     )  # define linear regression model vi_model <- parsnip::linear_reg() |>   parsnip::set_engine(\"lm\")  # create and fit workflow vi_workflow <- workflows::workflow() |>   workflows::add_recipe(vi_recipe) |>   workflows::add_model(vi_model) |>   workflows::fit(data = vi_smol)  vi_workflow  } } # }"},{"path":"https://blasbenito.github.io/collinear/reference/summary.collinear_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize all results of collinear() — summary.collinear_output","title":"Summarize all results of collinear() — summary.collinear_output","text":"Summarize results collinear()","code":""},{"path":"https://blasbenito.github.io/collinear/reference/summary.collinear_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize all results of collinear() — summary.collinear_output","text":"","code":"# S3 method for class 'collinear_output' summary(object = NULL, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/summary.collinear_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize all results of collinear() — summary.collinear_output","text":"object (required, list class collinear_output) Object summarize. Default: NULL ... Ignored, kept consistency generic.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/summary.collinear_output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize all results of collinear() — summary.collinear_output","text":"list: object created responses = NULL, sublist named \"result\" containing vector selected predictors. Otherwise, list named response containing corresponding variable selection.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/summary.collinear_selection.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize single response selection results of collinear — summary.collinear_selection","title":"Summarize single response selection results of collinear — summary.collinear_selection","text":"Summarize single response selection results collinear","code":""},{"path":"https://blasbenito.github.io/collinear/reference/summary.collinear_selection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize single response selection results of collinear — summary.collinear_selection","text":"","code":"# S3 method for class 'collinear_selection' summary(object = NULL, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/summary.collinear_selection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize single response selection results of collinear — summary.collinear_selection","text":"object (sub-list output collinear() ) Object summarize. Default: NULL ... Ignored, kept consistency generic.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/summary.collinear_selection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize single response selection results of collinear — summary.collinear_selection","text":"list: response name character vector selected predictors.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_lab.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert categorical predictors to numeric via target encoding — target_encoding_lab","title":"Convert categorical predictors to numeric via target encoding — target_encoding_lab","text":"Target encoding maps values categorical variables (class character factor) numeric using another numeric variable reference. encoding methods implemented : \"mean\" (implemented target_encoding_mean()): Maps category average reference numeric variable across category cases. Variables encoded method identified suffix \"__encoded_mean\". method control overfitting implemented via argument smoothing. integer value argument indicates threshold number rows. Categories sized threshold encoded group mean, groups encoded weighted mean group's mean global mean. method named \"mean smoothing\" relevant literature. \"rank\" (implemented target_encoding_rank()): Returns rank group integer, 1 group lower mean reference variable. Variables encoded method identified suffix \"__encoded_rank\". \"loo\" (implemented target_encoding_loo()): Known \"leave-one-method\" literature, encodes categorical value mean response variable across group cases. method controls overfitting better \"mean\". Variables encoded method identified suffix \"__encoded_loo\". Accepts parallelization setup via future::plan() progress bar via progressr::handlers() (see examples).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_lab.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert categorical predictors to numeric via target encoding — target_encoding_lab","text":"","code":"target_encoding_lab(   df = NULL,   response = NULL,   predictors = NULL,   encoding_method = \"loo\",   smoothing = 0,   overwrite = FALSE,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_lab.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert categorical predictors to numeric via target encoding — target_encoding_lab","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional, character string) Name numeric response variable df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. encoding_method (optional; character vector NULL). Name target encoding methods. One several : \"mean\", \"rank\", \"loo\". NULL, target encoding ignored, df returned modification. Default: \"loo\" smoothing (optional; integer vector) Argument method \"mean\". Groups smaller number means pulled towards mean response across cases. Default: 0 overwrite (optional; logical) TRUE, original predictors df overwritten encoded versions, one encoding method, smoothing, white noise, seed allowed. Otherwise, encoded predictors descriptive names added df. Default: FALSE quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_lab.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert categorical predictors to numeric via target encoding — target_encoding_lab","text":"dataframe","code":""},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_lab.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Convert categorical predictors to numeric via target encoding — target_encoding_lab","text":"Micci-Barreca, D. (2001) Preprocessing Scheme High-Cardinality Categorical Attributes Classification Prediction Problems. SIGKDD Explor. Newsl. 3, 1, 27-32. doi: 10.1145/507533.507538","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_lab.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert categorical predictors to numeric via target encoding — target_encoding_lab","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_lab.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert categorical predictors to numeric via target encoding — target_encoding_lab","text":"","code":"data(vi_smol)  #applying all methods for a continuous response df <- target_encoding_lab(   df = vi_smol,   response = \"vi_numeric\",   predictors = \"koppen_zone\",   encoding_method = c(     \"mean\",     \"loo\",     \"rank\"   ) ) #>  #> collinear::target_encoding_lab() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::target_encoding_lab(): using response 'vi_numeric' to encode these categorical predictors: #>  - koppen_zone  #identify encoded predictors predictors.encoded <- grep(   pattern = \"*__encoded*\",   x = colnames(df),   value = TRUE )  head(df[, predictors.encoded]) #>       koppen_zone__encoded_mean koppen_zone__encoded_loo #> 17401                 0.3233333                0.3231250 #> 24388                 0.5233028                0.5225926 #> 4775                  0.6555814                0.6566667 #> 26753                 0.5233028                0.5237037 #> 13218                 0.6676000                0.6633333 #> 26109                 0.5233028                0.5225000 #>       koppen_zone__encoded_rank #> 17401                         7 #> 24388                         7 #> 4775                          7 #> 26753                         7 #> 13218                         7 #> 26109                         7"},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Encode categories as response means — target_encoding_loo","title":"Encode categories as response means — target_encoding_loo","text":"Encode categories response means","code":""},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Encode categories as response means — target_encoding_loo","text":"","code":"target_encoding_loo(   df = NULL,   response = NULL,   predictor = NULL,   encoded_name = NULL,   smoothing = NULL,   ... )  target_encoding_mean(   df = NULL,   response = NULL,   predictor = NULL,   encoded_name = NULL,   smoothing = 0,   ... )  target_encoding_rank(   df = NULL,   response = NULL,   predictor = NULL,   encoded_name = NULL,   smoothing = NULL,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Encode categories as response means — target_encoding_loo","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional, character string) Name numeric response variable df. Default: NULL. predictor (required; string) Name categorical predictor encode. Default: NULL encoded_name (optional, string) Name encoded predictor. Default: NULL smoothing (optional; integer) Groups smaller number means pulled towards mean response across cases. Ignored target_encoding_rank() target_encoding_loo(). Default: 0 ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Encode categories as response means — target_encoding_loo","text":"dataframe","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/target_encoding_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Encode categories as response means — target_encoding_loo","text":"","code":"#  loading example data data(vi_smol)  #mean encoding #-------------  df <- target_encoding_mean(   df = vi_smol,   response = \"vi_numeric\",   predictor = \"soil_type\", #categorical   encoded_name = \"soil_type_encoded\" )  if(interactive()){    plot(     x = df$soil_type_encoded,     y = df$vi_numeric,     xlab = \"encoded variable\",     ylab = \"response\"   )  }   #rank encoding #----------  df <- target_encoding_rank(   df = vi_smol,   response = \"vi_numeric\",   predictor = \"soil_type\",   encoded_name = \"soil_type_encoded\" )  if(interactive()){    plot(     x = df$soil_type_encoded,     y = df$vi_numeric,     xlab = \"encoded variable\",     ylab = \"response\"   )  }   #leave-one-out #-------------  df <- target_encoding_loo(   df = vi_smol,   response = \"vi_numeric\",   predictor = \"soil_type\",   encoded_name = \"soil_type_encoded\" )  if(interactive()){    plot(     x = df$soil_type_encoded,     y = df$vi_numeric,     xlab = \"encoded variable\",     ylab = \"response\"   )  }"},{"path":"https://blasbenito.github.io/collinear/reference/toy.html","id":null,"dir":"Reference","previous_headings":"","what":"Toy dataframe with varying levels of multicollinearity — toy","title":"Toy dataframe with varying levels of multicollinearity — toy","text":"Dataframe known relationship responses predictors useful illustrate multicollinearity concepts.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/toy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Toy dataframe with varying levels of multicollinearity — toy","text":"","code":"data(toy)"},{"path":"https://blasbenito.github.io/collinear/reference/toy.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Toy dataframe with varying levels of multicollinearity — toy","text":"dataframe 2000 rows 5 columns.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/toy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Toy dataframe with varying levels of multicollinearity — toy","text":"Columns: y: response variable generated * 0.75 + b * 0.25 + noise. : important predictor y, uncorrelated b. b: second important predictor y, uncorrelated . c: generated + noise. d: generated (+ b)/2 + noise. variance inflation factors predictors toy. variable vif b       4.062 d       6.804 c       13.263       16.161","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and prepare argument df — validate_arg_df","title":"Check and prepare argument df — validate_arg_df","text":"Internal function validate integrity argument df. ensures dataframe suitable dimensions multicollinearity analysis, transforms logical columns numeric, character columns factors, converts NaN, Inf -Inf NA. Additionally, checks values responses predictors arguments provided.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and prepare argument df — validate_arg_df","text":"","code":"validate_arg_df(   df = NULL,   responses = NULL,   predictors = NULL,   quiet = FALSE,   function_name = NULL )"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and prepare argument df — validate_arg_df","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and prepare argument df — validate_arg_df","text":"dataframe","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and prepare argument df — validate_arg_df","text":"","code":"data(vi_smol, vi_predictors)  df <- validate_arg_df(   df = vi_smol,   responses = \"vi_numeric\",   predictors = vi_predictors_numeric,   quiet = FALSE )  attributes(vi)$validated #> NULL"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df_not_null.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure that argument df is not NULL — validate_arg_df_not_null","title":"Ensure that argument df is not NULL — validate_arg_df_not_null","text":"Internal function validate default value argument df.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df_not_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure that argument df is not NULL — validate_arg_df_not_null","text":"","code":"validate_arg_df_not_null(df = NULL, function_name = NULL)"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df_not_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure that argument df is not NULL — validate_arg_df_not_null","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df_not_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure that argument df is not NULL — validate_arg_df_not_null","text":"dataframe","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_df_not_null.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure that argument df is not NULL — validate_arg_df_not_null","text":"","code":"data(vi_smol) df <- validate_arg_df_not_null(   df = vi_smol   )"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_encoding_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and validate argument encoding_method — validate_arg_encoding_method","title":"Check and validate argument encoding_method — validate_arg_encoding_method","text":"Internal function validate argument encoding_method target_encoding_lab().","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_encoding_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and validate argument encoding_method — validate_arg_encoding_method","text":"","code":"validate_arg_encoding_method(   encoding_method = \"loo\",   overwrite = NULL,   quiet = FALSE,   function_name = NULL )"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_encoding_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and validate argument encoding_method — validate_arg_encoding_method","text":"encoding_method (optional; character vector NULL). Name target encoding methods. One several : \"mean\", \"rank\", \"loo\". NULL, target encoding ignored, df returned modification. Default: \"loo\" overwrite (optional; logical) TRUE, original predictors df overwritten encoded versions, one encoding method, smoothing, white noise, seed allowed. Otherwise, encoded predictors descriptive names added df. Default: FALSE quiet (optional; logical) FALSE, messages printed. Default: FALSE. function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_encoding_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and validate argument encoding_method — validate_arg_encoding_method","text":"character","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_encoding_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and validate argument encoding_method — validate_arg_encoding_method","text":"","code":"x <- validate_arg_encoding_method(   encoding_method = \"wrong_method\"   ) #>  #> collinear::validate_arg_encoding_method(): argument 'encoding_method' is not valid, resetting it to 'loo'."},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_f.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and validate argument f — validate_arg_f","title":"Check and validate argument f — validate_arg_f","text":"Check validate argument f","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and validate argument f — validate_arg_f","text":"","code":"validate_arg_f(f = NULL, f_name = NULL, function_name = NULL)"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and validate argument f — validate_arg_f","text":"f (optional: function name) Unquoted function name without parenthesis (see f_functions). default calls f_auto(), selects suitable function depending nature response predictors. Set NULL responses = NULL. NULL, predictors ranked lower higher multicollinearity. Default: f_auto f_name (optional, string) Name function f, returned deparse(substitute(f)). Default: NULL function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and validate argument f — validate_arg_f","text":"function","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_f.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and validate argument f — validate_arg_f","text":"","code":"x <- validate_arg_f(f = f_auto)"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_function_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Build hierarchical function names for messages — validate_arg_function_name","title":"Build hierarchical function names for messages — validate_arg_function_name","text":"Concatenates parent child function names better message, warning, error tracing.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_function_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build hierarchical function names for messages — validate_arg_function_name","text":"","code":"validate_arg_function_name(default_name = NULL, function_name = NULL, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_function_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build hierarchical function names for messages — validate_arg_function_name","text":"default_name (optional, character) Name calling function. Default: NULL function_name (optional, character) Name parent function. Default: NULL ... (optional) Used pass function_name within functions argument.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_function_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build hierarchical function names for messages — validate_arg_function_name","text":"character","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_function_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build hierarchical function names for messages — validate_arg_function_name","text":"","code":"x <- validate_arg_function_name(   default_name = \"child_function\",   function_name = \"parent_function\" )  message(x) #> parent_function #> └── child_function"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and constrain argument max_cor — validate_arg_max_cor","title":"Check and constrain argument max_cor — validate_arg_max_cor","text":"Check constrain argument max_cor","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and constrain argument max_cor — validate_arg_max_cor","text":"","code":"validate_arg_max_cor(max_cor = NULL, quiet = FALSE, function_name = NULL)"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and constrain argument max_cor — validate_arg_max_cor","text":"max_cor (optional; numeric NULL) Maximum correlation allowed pairs predictors. Valid values 0.01 0.99, recommended values 0.5 (strict) 0.9 (permissive). Default: 0.7 quiet (optional; logical) FALSE, messages printed. Default: FALSE. function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and constrain argument max_cor — validate_arg_max_cor","text":"numeric NULL","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and constrain argument max_cor — validate_arg_max_cor","text":"","code":"x <- validate_arg_max_cor(   max_cor = 1.5, #wrong value   quiet = FALSE ) #>  #> collinear::validate_arg_max_cor(): argument 'max_cor' is outside its valid range (>=0.1 to <=1), resetting it to '0.7'.  x #> [1] 0.7 #> attr(,\"validated\") #> [1] TRUE attributes(x)$validated #> [1] TRUE"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_vif.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and constrain argument max_vif — validate_arg_max_vif","title":"Check and constrain argument max_vif — validate_arg_max_vif","text":"Check constrain argument max_vif","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_vif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and constrain argument max_vif — validate_arg_max_vif","text":"","code":"validate_arg_max_vif(max_vif = NULL, quiet = FALSE, function_name = NULL)"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_vif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and constrain argument max_vif — validate_arg_max_vif","text":"max_vif (optional, numeric NULL) Maximum Variance Inflation Factor allowed predictors multicollinearity filtering. Recommended values 2.5 (strict) 10 (permissive). Default: 5 quiet (optional; logical) FALSE, messages printed. Default: FALSE. function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_vif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and constrain argument max_vif — validate_arg_max_vif","text":"numeric NULL","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_max_vif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and constrain argument max_vif — validate_arg_max_vif","text":"","code":"max_vif <- validate_arg_max_vif(   max_vif = 11, #wrong value   quiet = FALSE ) #>  #> collinear::validate_arg_max_vif(): argument 'max_vif' is outside its valid range (>=1 to <=10), resetting it to '5'.  max_vif #> [1] 5 #> attr(,\"validated\") #> [1] TRUE attributes(max_vif)$validated #> [1] TRUE"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_predictors.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and validate argument predictors — validate_arg_predictors","title":"Check and validate argument predictors — validate_arg_predictors","text":"Validates argument predictors ensuring provided predictors df intersect responses, .","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_predictors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and validate argument predictors — validate_arg_predictors","text":"","code":"validate_arg_predictors(   df = NULL,   responses = NULL,   predictors = NULL,   quiet = FALSE,   function_name = NULL )"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_predictors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and validate argument predictors — validate_arg_predictors","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_predictors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and validate argument predictors — validate_arg_predictors","text":"character vector: predictor names","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_predictors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and validate argument predictors — validate_arg_predictors","text":"","code":"data(vi_smol, vi_predictors)  x <- validate_arg_predictors(   df = vi_smol,   predictors = vi_predictors )  attributes(x)$validated #> [1] TRUE"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_preference_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and complete argument preference_order — validate_arg_preference_order","title":"Check and complete argument preference_order — validate_arg_preference_order","text":"Internal function validate argument preference_order cor_select(), vif_select(), collinear_select(), collinear(), collinear(). Predictors preference_order ranked lower higher sum Pearson correlations predictors.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_preference_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and complete argument preference_order — validate_arg_preference_order","text":"","code":"validate_arg_preference_order(   df = NULL,   response = NULL,   predictors = NULL,   preference_order = NULL,   quiet = FALSE,   function_name = NULL,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_preference_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and complete argument preference_order — validate_arg_preference_order","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional, character string) Name numeric response variable df. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. preference_order (optional; character vector, dataframe preference_order, NULL) Prioritizes predictors preserve. quiet (optional; logical) FALSE, messages printed. Default: FALSE. function_name (optional, character string) Name function performing argument check. Default: NULL ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_preference_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and complete argument preference_order — validate_arg_preference_order","text":"character vector: ranked variable names","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_preference_order.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and complete argument preference_order — validate_arg_preference_order","text":"","code":"data(   vi_smol,   vi_predictors_numeric   )  #input arguments must be validated first df <- validate_arg_df(   df = vi_smol,   response = \"vi_numeric\",   predictors = vi_predictors_numeric,   quiet = TRUE )  response <- validate_arg_responses(   df = df,   responses = \"vi_numeric\" )  predictors <- validate_arg_predictors(   df = df,   response = response,   predictors = vi_predictors_numeric[1:10] )    #no preference order #no response #ranks predictor from lower to higher multicollinearity y <- validate_arg_preference_order(   df = df,   predictors = predictors,   preference_order = NULL ) #>  #> collinear::validate_arg_preference_order() #> └── collinear::preference_order(): ranking 10 'predictors' from lower to higher multicollinearity.  y #>    response             predictor            f        metric  score rank #> 1      none        topo_elevation stats::cor() 1 - R-squared 0.8184    1 #> 2      none        topo_diversity stats::cor() 1 - R-squared 0.8183    2 #> 3      none            topo_slope stats::cor() 1 - R-squared 0.8001    3 #> 4      none  soil_temperature_min stats::cor() 1 - R-squared 0.7434    4 #> 5      none             swi_range stats::cor() 1 - R-squared 0.7387    5 #> 6      none soil_temperature_mean stats::cor() 1 - R-squared 0.6534    6 #> 7      none              swi_mean stats::cor() 1 - R-squared 0.6272    7 #> 8      none               swi_max stats::cor() 1 - R-squared 0.6259    8 #> 9      none               swi_min stats::cor() 1 - R-squared 0.6170    9 #> 10     none  soil_temperature_max stats::cor() 1 - R-squared 0.6021   10 attributes(y)$validated #> [1] TRUE   #validate character vector y <- validate_arg_preference_order(   df = df,   predictors = predictors,   preference_order = c(     \"swi_max\",     \"swi_min\",     \"swi_deviance\" #does not exist   ) ) #>  #> collinear::validate_arg_preference_order() #> └── collinear::preference_order(): ranking 8 'predictors' from lower to higher multicollinearity.  y #>    response             predictor            f          metric  score rank #> 1      none               swi_max         <NA> user_preference 1.0000    1 #> 2      none               swi_min         <NA> user_preference 0.0000    2 #> 3      none        topo_diversity stats::cor()   1 - R-squared 0.8049    3 #> 4      none             swi_range stats::cor()   1 - R-squared 0.7981    4 #> 5      none        topo_elevation stats::cor()   1 - R-squared 0.7859    5 #> 6      none            topo_slope stats::cor()   1 - R-squared 0.7855    6 #> 7      none  soil_temperature_min stats::cor()   1 - R-squared 0.7452    7 #> 8      none              swi_mean stats::cor()   1 - R-squared 0.7229    8 #> 9      none soil_temperature_mean stats::cor()   1 - R-squared 0.7057    9 #> 10     none  soil_temperature_max stats::cor()   1 - R-squared 0.6854   10 attributes(y)$validated #> [1] TRUE  #validate output of preference order x <- preference_order(   df = df,   responses = response,   predictors = predictors ) #>  #> collinear::preference_order() #> └── collinear::f_auto(): selected function 'f_numeric_glm()' to compute preference order.  x #>      response             predictor             f    metric  score rank #> 1  vi_numeric              swi_mean f_numeric_glm R-squared 0.7182    1 #> 2  vi_numeric               swi_max f_numeric_glm R-squared 0.5549    2 #> 3  vi_numeric  soil_temperature_max f_numeric_glm R-squared 0.5462    3 #> 4  vi_numeric             swi_range f_numeric_glm R-squared 0.4225    4 #> 5  vi_numeric               swi_min f_numeric_glm R-squared 0.2130    5 #> 6  vi_numeric  soil_temperature_min f_numeric_glm R-squared 0.0972    6 #> 7  vi_numeric        topo_diversity f_numeric_glm R-squared 0.0663    7 #> 8  vi_numeric        topo_elevation f_numeric_glm R-squared 0.0351    8 #> 9  vi_numeric            topo_slope f_numeric_glm R-squared 0.0176    9 #> 10 vi_numeric soil_temperature_mean f_numeric_glm R-squared 0.0151   10  y <- validate_arg_preference_order(   df = df,   response = response,   predictors = predictors,   preference_order = x )  y #>      response             predictor             f    metric  score rank #> 1  vi_numeric              swi_mean f_numeric_glm R-squared 0.7182    1 #> 2  vi_numeric               swi_max f_numeric_glm R-squared 0.5549    2 #> 3  vi_numeric  soil_temperature_max f_numeric_glm R-squared 0.5462    3 #> 4  vi_numeric             swi_range f_numeric_glm R-squared 0.4225    4 #> 5  vi_numeric               swi_min f_numeric_glm R-squared 0.2130    5 #> 6  vi_numeric  soil_temperature_min f_numeric_glm R-squared 0.0972    6 #> 7  vi_numeric        topo_diversity f_numeric_glm R-squared 0.0663    7 #> 8  vi_numeric        topo_elevation f_numeric_glm R-squared 0.0351    8 #> 9  vi_numeric            topo_slope f_numeric_glm R-squared 0.0176    9 #> 10 vi_numeric soil_temperature_mean f_numeric_glm R-squared 0.0151   10 attributes(y)$validated #> [1] TRUE"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_quiet.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and validate argument quiet — validate_arg_quiet","title":"Check and validate argument quiet — validate_arg_quiet","text":"Internal function validate logical argument quiet, triggers messaging FALSE","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_quiet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and validate argument quiet — validate_arg_quiet","text":"","code":"validate_arg_quiet(quiet = FALSE, function_name = NULL)"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_quiet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and validate argument quiet — validate_arg_quiet","text":"quiet (optional; logical) FALSE, messages printed. Default: FALSE. function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_quiet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and validate argument quiet — validate_arg_quiet","text":"logical","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_quiet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and validate argument quiet — validate_arg_quiet","text":"","code":"x <- validate_arg_quiet(   quiet = TRUE   )  attributes(x)$validated #> NULL"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_responses.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and validate arguments response and responses — validate_arg_responses","title":"Check and validate arguments response and responses — validate_arg_responses","text":"Internal function validate arguments response responses. checks value exists column name df,","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_responses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and validate arguments response and responses — validate_arg_responses","text":"","code":"validate_arg_responses(   df = NULL,   responses = NULL,   max_responses = NULL,   quiet = FALSE,   function_name = NULL )"},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_responses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and validate arguments response and responses — validate_arg_responses","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. responses (optional; character, character vector, NULL) Name one several response variables df. Default: NULL. max_responses (required, integer NULL) Maximum number responses consider. Default: NULL quiet (optional; logical) FALSE, messages printed. Default: FALSE. function_name (optional, character string) Name function performing argument check. Default: NULL","code":""},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_responses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and validate arguments response and responses — validate_arg_responses","text":"character string: response name","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/validate_arg_responses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and validate arguments response and responses — validate_arg_responses","text":"","code":"data(vi_smol)  x <- validate_arg_responses(   df = vi_smol,   responses = \"vi_numeric\" )  attributes(x)$validated #> [1] TRUE"},{"path":"https://blasbenito.github.io/collinear/reference/vi.html","id":null,"dir":"Reference","previous_headings":"","what":"Large example dataframe — vi","title":"Large example dataframe — vi","text":"response variable Vegetation Index encoded different ways help highlight package capabilities: vi_numeric: continuous vegetation index values range 0-1. vi_counts: simulated integer counts created multiplying vi_numeric 1000 coercing result integer. vi_binomial: simulated integer binomial variable created transforming vi_numeric zeros ones. vi_categorical: character variable categories \"very_low\", \"low\", \"medium\", \"high\", \"very_high\", thresholds located quantiles vi_numeric. vi_factor: vi_categorical converted factor. names predictors (continuous, integer, character, factors) vi_predictors.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Large example dataframe — vi","text":"","code":"data(vi)"},{"path":"https://blasbenito.github.io/collinear/reference/vi.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Large example dataframe — vi","text":"dataframe 30.000 rows 68 columns.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector of all predictor names in vi and vi_smol — vi_predictors","title":"Vector of all predictor names in vi and vi_smol — vi_predictors","text":"Vector predictor names vi vi_smol","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector of all predictor names in vi and vi_smol — vi_predictors","text":"","code":"data(vi_predictors)"},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Vector of all predictor names in vi and vi_smol — vi_predictors","text":"Character vector predictor names.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors_categorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector of categorical predictors in vi and vi_smol — vi_predictors_categorical","title":"Vector of categorical predictors in vi and vi_smol — vi_predictors_categorical","text":"Vector categorical predictors vi vi_smol","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors_categorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector of categorical predictors in vi and vi_smol — vi_predictors_categorical","text":"","code":"data(vi_predictors_categorical)"},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors_categorical.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Vector of categorical predictors in vi and vi_smol — vi_predictors_categorical","text":"Character vector predictor names.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector of numeric predictor names in vi and vi_smol — vi_predictors_numeric","title":"Vector of numeric predictor names in vi and vi_smol — vi_predictors_numeric","text":"Vector numeric predictor names vi vi_smol","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector of numeric predictor names in vi and vi_smol — vi_predictors_numeric","text":"","code":"data(vi_predictors_numeric)"},{"path":"https://blasbenito.github.io/collinear/reference/vi_predictors_numeric.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Vector of numeric predictor names in vi and vi_smol — vi_predictors_numeric","text":"Character vector predictor names.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vi_responses.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector of response names in vi and vi_smol — vi_responses","title":"Vector of response names in vi and vi_smol — vi_responses","text":"Vector response names vi vi_smol","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vi_responses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector of response names in vi and vi_smol — vi_responses","text":"","code":"data(vi_responses)"},{"path":"https://blasbenito.github.io/collinear/reference/vi_responses.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Vector of response names in vi and vi_smol — vi_responses","text":"Character vector response names.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vi_smol.html","id":null,"dir":"Reference","previous_headings":"","what":"Small example dataframe — vi_smol","title":"Small example dataframe — vi_smol","text":"dataset vi, 610 rows. Used code examples shorten runtime.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vi_smol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Small example dataframe — vi_smol","text":"","code":"data(vi_smol)"},{"path":"https://blasbenito.github.io/collinear/reference/vi_smol.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Small example dataframe — vi_smol","text":"dataframe 100 rows 68 columns.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vif.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute variance inflation factors from a correlation matrix — vif","title":"Compute variance inflation factors from a correlation matrix — vif","text":"Computes Variance Inflation Factors correlation matrix two steps: Applies base::solve() transform correlation matrix precision matrix, inverse covariance matrix variables predictors. Applies base::diag() extract diagonal precision matrix, contains variance regression predictor predictors, also known Variance Inflation Factor","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute variance inflation factors from a correlation matrix — vif","text":"","code":"vif(m = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/vif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute variance inflation factors from a correlation matrix — vif","text":"m (required, matrix) Correlation matrix generated via stats::cor() cor_matrix(). Must named dimensions. Default: NULL quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute variance inflation factors from a correlation matrix — vif","text":"named numeric vector","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif.html","id":"variance-inflation-factors","dir":"Reference","previous_headings":"","what":"Variance Inflation Factors","title":"Compute variance inflation factors from a correlation matrix — vif","text":"VIF predictor \\(\\) computed \\(1/(1-R^2)\\), \\(R^2\\) multiple R-squared regressing \\(\\) predictors. Recommended maximums commonly used 2.5, 5, 10.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute variance inflation factors from a correlation matrix — vif","text":"David . Belsley, D.., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data Sources Collinearity. John Wiley & Sons. DOI: 10.1002/0471725153.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute variance inflation factors from a correlation matrix — vif","text":"","code":"data(vi_smol, vi_predictors_numeric)  m <- cor_matrix(   df = vi_smol,   predictors = vi_predictors_numeric[1:5] )  vif(m) #>       swi_mean        swi_max     topo_slope topo_diversity topo_elevation  #>         5.4512         5.0707         1.6719         1.5817         1.4120"},{"path":"https://blasbenito.github.io/collinear/reference/vif_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute variance inflation factors dataframe — vif_df","title":"Compute variance inflation factors dataframe — vif_df","text":"Computes pairwise correlation matrix pairs predictors via cor_df() cor_matrix(), applies vif() resulting matrix compute Variance Inflation Factors, returns result dataframe.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute variance inflation factors dataframe — vif_df","text":"","code":"vif_df(df = NULL, predictors = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/vif_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute variance inflation factors dataframe — vif_df","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute variance inflation factors dataframe — vif_df","text":"dataframe columns: predictor: Character, predictor name. vif: Numeric, variance inflation factor","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_df.html","id":"variance-inflation-factors","dir":"Reference","previous_headings":"","what":"Variance Inflation Factors","title":"Compute variance inflation factors dataframe — vif_df","text":"VIF predictor \\(\\) computed \\(1/(1-R^2)\\), \\(R^2\\) multiple R-squared regressing \\(\\) predictors. Recommended maximums commonly used 2.5, 5, 10.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_df.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute variance inflation factors dataframe — vif_df","text":"David . Belsley, D.., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data Sources Collinearity. John Wiley & Sons. DOI: 10.1002/0471725153.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vif_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute variance inflation factors dataframe — vif_df","text":"","code":"data(vi_smol)  # ## OPTIONAL: parallelization setup # ## irrelevant when all predictors are numeric # ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  # ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  #predictors predictors = c(   \"koppen_zone\", #character   \"soil_type\", #factor   \"topo_elevation\", #numeric   \"soil_temperature_mean\" #numeric )  x <- vif_df(   df = vi_smol,   predictors = predictors ) #>  #> collinear::vif_df() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::vif_df() #> └── collinear::cor_matrix() #>     └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  x #>       vif             predictor #> 1  0.7927           koppen_zone #> 2 -0.0356 soil_temperature_mean #> 3 -0.4397             soil_type #> 4 -0.9578        topo_elevation  ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":null,"dir":"Reference","previous_headings":"","what":"Multicollinearity filtering by variance inflation factor threshold — vif_select","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"Wraps collinear_select() automatize multicollinearity filtering via variance inflation factors (VIF) dataframes numeric categorical predictors. argument max_vif determines maximum variance inflation factor allowed resulting selection predictors. argument preference_order accepts character vector predictor names ranked first last index, dataframe resulting preference_order(). two predictors vector dataframe highly collinear, one lower ranking removed. option helps protect predictors interest. provided, predictors ranked lower higher multicollinearity. Please check sections Variance Inflation Factors VIF-based Filtering end help file details.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"","code":"vif_select(   df = NULL,   response = NULL,   predictors = NULL,   preference_order = NULL,   max_vif = 5,   quiet = FALSE,   ... )"},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. response (optional; character NULL) Name one response variable df. Used exclude columns predictors NULL, filter preference_order dataframe contains several responses. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. preference_order (optional; character vector, dataframe preference_order, NULL) Prioritizes predictors preserve. max_vif (optional, numeric NULL) Maximum Variance Inflation Factor allowed predictors multicollinearity filtering. Recommended values 2.5 (strict) 10 (permissive). Default: 5 quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"character vector selected predictors","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":"variance-inflation-factors","dir":"Reference","previous_headings":"","what":"Variance Inflation Factors","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"VIF predictor \\(\\) computed \\(1/(1-R^2)\\), \\(R^2\\) multiple R-squared regressing \\(\\) predictors. Recommended maximums commonly used 2.5, 5, 10.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":"vif-based-filtering","dir":"Reference","previous_headings":"","what":"VIF-based Filtering","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"vif_select ranks numeric predictors (user preference_order provided, otherwise lower higher VIF) sequentially adds predictors whose VIF current selection max_vif.","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"David . Belsley, D.., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data Sources Collinearity. John Wiley & Sons. DOI: 10.1002/0471725153.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"Blas M. Benito, PhD","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_select.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multicollinearity filtering by variance inflation factor threshold — vif_select","text":"","code":"data(vi_smol)  ## OPTIONAL: parallelization setup ## irrelevant when all predictors are numeric ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  #predictors predictors = c(   \"koppen_zone\", #character   \"soil_type\", #factor   \"topo_elevation\", #numeric   \"soil_temperature_mean\" #numeric )  #predictors ordered from lower to higher multicollinearity x <- vif_select(   df = vi_smol,   predictors = predictors,   max_vif = 5 ) #>  #> collinear::vif_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::vif_select() #> └── collinear::collinear_select() #>     └── collinear::cor_matrix() #>         └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. #>  #> collinear::vif_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_preference_order() #>         └── collinear::preference_order(): ranking 4 'predictors' from lower to higher multicollinearity. #>  #> collinear::vif_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_preference_order() #>         └── collinear::preference_order() #>             └── collinear::cor_matrix() #>                 └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. #>  #> collinear::vif_select() #> └── collinear::collinear_select(): maximum VIF is <= 5, multicollinearity filtering is not required.  x #> [1] \"koppen_zone\"           \"soil_type\"             \"topo_elevation\"        #> [4] \"soil_temperature_mean\" #> attr(,\"validated\") #> [1] TRUE   #with custom preference order x <- vif_select(   df = vi_smol,   predictors = predictors,   preference_order = c(     \"koppen_zone\",     \"soil_type\"   ),   max_vif = 5 ) #>  #> collinear::vif_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::vif_select() #> └── collinear::collinear_select() #>     └── collinear::cor_matrix() #>         └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue. #>  #> collinear::vif_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_preference_order() #>         └── collinear::preference_order(): ranking 2 'predictors' from lower to higher multicollinearity. #>  #> collinear::vif_select() #> └── collinear::collinear_select(): maximum VIF is <= 5, multicollinearity filtering is not required.  x #> [1] \"koppen_zone\"           \"soil_type\"             \"topo_elevation\"        #> [4] \"soil_temperature_mean\" #> attr(,\"validated\") #> [1] TRUE   #with automated preference order df_preference <- preference_order(   df = vi_smol,   response = \"vi_numeric\",   predictors = predictors ) #>  #> collinear::preference_order() #> └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::preference_order() #> └── collinear::f_auto(): selected function 'f_numeric_rf()' to compute preference order.  df_preference #>     response             predictor            f    metric  score rank #> 1 vi_numeric           koppen_zone f_numeric_rf R-squared 0.8174    1 #> 2 vi_numeric             soil_type f_numeric_rf R-squared 0.6249    2 #> 3 vi_numeric soil_temperature_mean f_numeric_rf R-squared 0.4201    3 #> 4 vi_numeric        topo_elevation f_numeric_rf R-squared 0.3754    4  x <- cor_select(   df = vi_smol,   predictors = predictors,   preference_order = df_preference,   max_cor = 0.7 ) #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::validate_arg_df(): converted the following character columns to factor: #>  - koppen_zone #>  #> collinear::cor_select() #> └── collinear::collinear_select() #>     └── collinear::cor_matrix() #>         └── collinear::cor_df(): 2 categorical predictors have cardinality > 2 and may bias the multicollinearity analysis. Applying target encoding to convert them to numeric will solve this issue.  x #> [1] \"koppen_zone\"    \"soil_type\"      \"topo_elevation\" #> attr(,\"validated\") #> [1] TRUE  ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":"https://blasbenito.github.io/collinear/reference/vif_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"VIF Statistics — vif_stats","title":"VIF Statistics — vif_stats","text":"Computes minimum, mean, maximum, quantiles 0.05, 0.25, median (0.5), 0.75, 0.95 column \"vif\" output vif_df().","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VIF Statistics — vif_stats","text":"","code":"vif_stats(df = NULL, predictors = NULL, quiet = FALSE, ...)"},{"path":"https://blasbenito.github.io/collinear/reference/vif_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VIF Statistics — vif_stats","text":"df (required; dataframe, tibble, sf) dataframe responses (optional) predictors. Must least 10 rows pairwise correlation analysis, 10 * (length(predictors) - 1) VIF. Default: NULL. predictors (optional; character vector NULL) Names predictors df. NULL, columns except responses constant/near-zero-variance columns used. Default: NULL. quiet (optional; logical) FALSE, messages printed. Default: FALSE. ... (optional) Internal args (e.g. function_name validate_arg_function_name, precomputed correlation matrix m, cross-validation args preference_order).","code":""},{"path":"https://blasbenito.github.io/collinear/reference/vif_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"VIF Statistics — vif_stats","text":"dataframe columns method value \"vif\", statistic statistic name, value.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/reference/vif_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"VIF Statistics — vif_stats","text":"","code":"data(   vi_smol,   vi_predictors_numeric   )  # ## OPTIONAL: parallelization setup # ## irrelevant when all predictors are numeric # ## only worth it for large data with many categoricals # future::plan( #   future::multisession, #   workers = future::availableCores() - 1 # )  # ## OPTIONAL: progress bar # progressr::handlers(global = TRUE)  x <- vif_stats(   df = vi_smol,   predictors = vi_predictors_numeric )  x #>   method     statistic    value #> 1    vif             n  47.0000 #> 2    vif       minimum   1.8158 #> 3    vif quantile_0.05   3.7499 #> 4    vif quantile_0.25  58.1814 #> 5    vif          mean 214.5167 #> 6    vif        median 170.1444 #> 7    vif quantile_0.75 354.2920 #> 8    vif quantile_0.95 520.9411 #> 9    vif       maximum 553.2944  ## OPTIONAL: disable parallelization #future::plan(future::sequential)"},{"path":[]},{"path":[]},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"api-changes-3-0-0","dir":"Changelog","previous_headings":"Breaking Changes","what":"API Changes","title":"collinear 3.0.0","text":"Argument response renamed responses: Now accepts multiple response variables. Functions affected: collinear(), preference_order(), related validation functions. Argument encoding_method defaults NULL collinear(): Target encoding now opt-rather automatic. Previously defaulted \"mean\". Default values changed max_cor max_vif: now default NULL, triggering adaptive threshold computation based correlation structure data. Output structure changed collinear(): Now returns list class collinear_output containing sub-lists class collinear_selection, response, df, preference_order, selection, formulas slots. Previously returned character vector named list character vectors.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"adaptive-multicollinearity-thresholds-3-0-0","dir":"Changelog","previous_headings":"Major New Features","what":"Adaptive Multicollinearity Thresholds","title":"collinear 3.0.0","text":"max_cor = NULL max_vif = NULL, function now automatically determines optimal filtering thresholds using: 75th percentile pairwise correlations input sigmoid transformation smoothly transitions . conservative (VIF ≈ 2.5) permissive (VIF ≈ 7.5) thresholds. GAM model (gam_cor_to_vif) mapping correlation thresholds equivalent VIF values. data-driven approach adapts dataset’s correlation structure, preventing -filtering maintaining statistically meaningful bounds.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"tidymodels-integration-3-0-0","dir":"Changelog","previous_headings":"Major New Features","what":"Tidymodels Integration","title":"collinear 3.0.0","text":"New step_collinear(): Recipe step multicollinearity filtering tidymodels workflows. Implements proper prep() bake() methods following recipes architecture.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"cross-validation-support-in-preference-order-3-0-0","dir":"Changelog","previous_headings":"Major New Features","what":"Cross-Validation Support in Preference Order","title":"collinear 3.0.0","text":"New arguments cv_training_fraction cv_iterations preference_order() passed collinear(). Enables robust predictor ranking repeated train/test splits.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"rich-output-structure-3-0-0","dir":"Changelog","previous_headings":"Major New Features","what":"Rich Output Structure","title":"collinear 3.0.0","text":"collinear() now returns comprehensive results including: Filtered dataframe response selected predictors. Preference order dataframe rankings. Ready--use model formulas (linear, smooth/GAM, classification). S3 methods print() summary() collinear_output collinear_selection classes provide clean output formatting.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"correlation-matrix-improvements-3-0-0","dir":"Changelog","previous_headings":"Major New Features","what":"Correlation Matrix Improvements","title":"collinear 3.0.0","text":"cor_matrix() now returns signed correlations, preserving positive semi-definite property required VIF calculations. Absolute values applied comparing max_cor thresholds. Fixes numerical instability produce negative VIF scores.","code":""},{"path":[]},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"multicollinearity-assessment-3-0-0","dir":"Changelog","previous_headings":"New Functions","what":"Multicollinearity Assessment","title":"collinear 3.0.0","text":"collinear_stats(): Compute summary statistics correlation VIF. cor_stats(): Summary statistics pairwise correlations. vif_stats(): Summary statistics variance inflation factors.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"preference-order-3-0-0","dir":"Changelog","previous_headings":"New Functions","what":"Preference Order","title":"collinear 3.0.0","text":"f_count_rf(): Score integer count predictors random forest.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"s3-methods-3-0-0","dir":"Changelog","previous_headings":"New Functions","what":"S3 Methods","title":"collinear 3.0.0","text":"print.collinear_output() print.collinear_selection() summary.collinear_output() summary.collinear_selection()","code":""},{"path":[]},{"path":[]},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"vif-computation-3-0-0","dir":"Changelog","previous_headings":"Improvements","what":"VIF Computation","title":"collinear 3.0.0","text":"Ridge regularization fallback near-singular matrices. Improved tolerance calculation solve() prevent false singularity detection. VIF values exceeding 1M now capped Inf.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"validation-3-0-0","dir":"Changelog","previous_headings":"Improvements","what":"Validation","title":"collinear 3.0.0","text":"New validate_arg_*() functions provide consistent argument checking across package. Hierarchical function name tracking clearer error messages.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"documentation-3-0-0","dir":"Changelog","previous_headings":"Improvements","what":"Documentation","title":"collinear 3.0.0","text":"Comprehensive roxygen documentation working examples. @family tags better cross-referencing. @inheritSection consistent documentation shared concepts.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"bug-fixes-3-0-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"collinear 3.0.0","text":"Fixed correlation matrix handling destroyed positive semi-definite property applying abs() VIF computation. Fixed edge cases VIF computation ill-conditioned matrices. Proper handling single-predictor cases across functions.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"deprecated-3-0-0","dir":"Changelog","previous_headings":"","what":"Deprecated","title":"collinear 3.0.0","text":"Value \"auto\" preference_order argument (ignored message)","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"collinear-200","dir":"Changelog","previous_headings":"","what":"collinear 2.0.0","title":"collinear 2.0.0","text":"CRAN release: 2024-11-08","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"main-improvements-2-0-0","dir":"Changelog","previous_headings":"","what":"Main Improvements","title":"collinear 2.0.0","text":"Expanded Functionality: Functions collinear() preference_order() support categorical numeric responses predictors, can handle several responses . Robust Selection Algorithms: Enhanced selection vif_select() cor_select(). Enhanced Functionality Rank Predictors: New functions compute association response predictors covering use-cases, automated function selection depending data features. Simplified Target Encoding: Streamlined parallelized better efficiency, new default \"loo\" (leave-one-). Parallelization Progress Bars: Utilizes future progressr enhanced performance user experience.","code":""},{"path":"https://blasbenito.github.io/collinear/news/index.html","id":"collinear-111","dir":"Changelog","previous_headings":"","what":"collinear 1.1.1","title":"collinear 1.1.1","text":"CRAN release: 2023-12-08 Initial CRAN release Basic multicollinearity filtering collinear(), cor_select(), vif_select() Target encoding methods: mean, rank, leave-one-Preference order functionality Support mixed numeric categorical predictors","code":""}]
